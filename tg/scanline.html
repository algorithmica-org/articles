<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Сканирующая прямая - Tinkoff Generation</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />

  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->

  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/tg/'><div id='logo'>Tinkoff Generation</div></a>
    <div id='links'>
        <a href='https://github.com/algorithmica-org/tg/edit/master/scanline.md'>Редактировать</a>
        <a href='https://github.com/algorithmica-org/tg/commits/master/scanline.md'>История</a>
    </div>
</div>
<div class="migration"><a href='https://ru.algorithmica.org/cs/'>Сайт переезжает.</a> Большинство статей уже перенесено на новую версию.<br>Скоро добавим автоматические переходы, но пока обновленную версию этой статьи можно найти там.</div>
<h1 id="сканирующая-прямая">Сканирующая прямая</h1>
<p>Общая идея этого алгоритма заключается в сортировке точек и затем проходу по ним(по этому алгоритм так и называется).</p>
<p>Давайте разберем несколько задач на эту тему и лучше поймем алгоритм.</p>
<h2 id="точка-покрытая-наибольшим-количеством-отрезков">Точка, покрытая наибольшим количеством отрезков</h2>
<p>Пусть, дан набор из <span class="math inline">\(n\)</span> отрезков на прямой, заданных координатами начал и концов <span class="math inline">\([l_i, r_i]\)</span>. Требуется найти любую точку на прямой, покрытую наибольшим количеством отрезков.</p>
<p>Понятно, что каждую точку прямой мы проверить не можем. В каких точках прямой может происходить смена количества отрезков, которыми она покрыта? Только в началах или концах данных отрезков. Назовем такие точки <em>интересными</em>. Так как смена ответа может происходить только в интересной точке, максимум достигается так же в какой-то из интересных точек. Отсюда сразу следует решение за <span class="math inline">\(O(n^2)\)</span>: просто перебрать все интересные точки и проверить для них ответ.</p>
<p>Это решение можно улучшить. Отсортируем интересные точки по возрастанию координаты. Пройдем по интересным точкам слева направо, поддерживая количество отрезков <span class="math inline">\(c\)</span>, которые покрывают данную точку. Если в данной точке начинается отрезок, то надо прибавить 1 к <span class="math inline">\(c\)</span>, а если заканчивается вычесть 1 из <span class="math inline">\(c\)</span>. После этого надо попробовать обновить ответ на задачу.</p>
<p>Заметим, что если координаты двух интересных точек совпали, чтобы получить правильный ответ, сначала надо рассмотреть начала отрезков, а потом концы.</p>
<p>Как такое писать: нужно представить интересные точки в виде структур с полями “координата” и “тип” (начало/конец) и отсортировать со своим компаратором. Удобно начало отрезка обозначать +1, а конец -1, чтобы прибавлять к <span class="math inline">\(c\)</span> именно это значение.</p>
<pre><code>struct event{
    int x, type;
};
int main(){
    int n;
    cin &gt;&gt; n;
    vector&lt;event&gt; a(n);
    for (int i = 0; i &lt; n; ++i)
        cin &gt;&gt; a[i].x &gt;&gt; a[i].type;
    sort(a.begin(), a.end(), [](const event&amp; e1, const event&amp; e2) {
        return e1.x == e2.x ? e1.type &lt; e2.type : e1.x &lt; e2.x; 
    });
}</code></pre>
<p>Такое решение работает за <span class="math inline">\(O(n\log n)\)</span> на сортировку. Этот подход называется методом сканирующей прямой.</p>
<h2 id="скольким-отрезкам-принадлежит-точка">Скольким отрезкам принадлежит точка</h2>
<p>Пусть, теперь надо для <span class="math inline">\(q\)</span> точек (не обязательно являющихся концами отрезков) ответить на вопрос: скольким отрезкам принадлежит данная точка?</p>
<p>Воспользуемся следующим приемом: сразу считаем все запросы и сохраним их, чтобы потом ответить на все сразу. Добавим точки запросов в массив интересных точек с новым типом 0, который будет означать, что в этой точке надо ответить на запрос. В случае равенства координат запросы должны идти после начал и до концов. Точно так же отсортируем точки и пройдем по точкам слева направо, поддерживая <span class="math inline">\(c\)</span> и запоминая ответы на запросы. Асимптотика <span class="math inline">\(O((n+q)\log(n+q))\)</span>.</p>
<h2 id="количество-пересекающихся-отрезков">Количество пересекающихся отрезков</h2>
<p>Пусть, дан набор из <span class="math inline">\(n\)</span> отрезков на прямой, заданных координатами начал и концов <span class="math inline">\([l_i, r_i]\)</span>. Требуется для каждого отрезка сказать, с каким количеством отрезков он пересекается (может иметь общую точку или быть вложенным).</p>
<p>Вместо того, чтобы считать количество отрезков, с которыми отрезок пересекается, посчитаем количество отрезков, с которыми он <strong>не</strong> пересекается, и вычтем это число из <span class="math inline">\(n-1\)</span>. Отрезок <span class="math inline">\([l_1, r_1]\)</span> может не пересекаться с другим отрезком <span class="math inline">\([l_2, r_2]\)</span>, только если <span class="math inline">\(r_2&lt;l_1\)</span> или <span class="math inline">\(r_1&lt;l_2\)</span>. Количество отрезков для каждого из случаев легко подсчитать.</p>
<p>Будем считать, что изначально ответ для всех отрезков равен <span class="math inline">\(n-1\)</span>. Запишем все интересные точки, отсортируем их. Пройдем слева направо, поддерживая число отрезков, которые уже закончились (изначально 0) и число отрезков, которые еще не начались (изначально <span class="math inline">\(n-1\)</span>). При обработке очередной точки, если это начало, вычитаем из ответа для этого отрезка число уже закончившихся, а если конец, то вычитаем количество еще не начавшихся. После этого изменяем значение соответствующего счетчика.</p>
<p>Заметим, что теперь в структуре точки необходимо хранить еще и номер отрезка, которому она принадлежала. Время работы <span class="math inline">\(O(n\log n)\)</span>.</p>
<h2 id="длина-объединения-отрезков">Длина объединения отрезков</h2>
<p>Пусть, дан набор из <span class="math inline">\(n\)</span> отрезков на прямой, заданных координатами начал и концов <span class="math inline">\([l_i, r_i]\)</span>. Требуется нати длину их объединения.</p>
<p>Как обычно, отсортируем интересные точки и при проходе поддерживаем число отрезков, покрывающих данную точку. Если оно больше 0, то отрезок который мы прошли с прошлой рассмторенной точки принадлежит объединению. Время работы <span class="math inline">\(O(n\log n)\)</span>.</p>
<h2 id="сжатие-координат">Сжатие координат</h2>
<p>Это общая идея, которая может оказаться полезной. Пусть, есть <span class="math inline">\(n\)</span> чисел <span class="math inline">\(a_1,\ldots,a_n\)</span>. Хотим, преобразовать <span class="math inline">\(a_i\)</span> так, чтобы равные остались равными, разные остались разными, но все они были от 0 до <span class="math inline">\(n-1\)</span>. Для этого надо отсортировать числа, удалить повторяющиеся и заменить каждое <span class="math inline">\(a_i\)</span> на его индекс в отсортированном массиве.</p>
<pre><code>int a[n], all[n];
for (int i = 0; i &lt; n; ++i) {
    cin &gt;&gt; a[i];
    all[i] = a[i];
}
sort(all, all + n);
m = unique(all, all + n) - all; // теперь m - число различных координат
for (int i = 0; i &lt; n; ++i)
    a[i] = lower_bound(all, all + m, x[i]) - all;</code></pre>
<h2 id="задание">Задание</h2>
<p>Решите как можно больше задач из контеста https://informatics.msk.ru/mod/statements/view.php?id=33318</p>
</body>
</html>
