<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Бинарный поиск - Tinkoff Generation</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />

  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->

  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/tg/'><div id='logo'>Tinkoff Generation</div></a>
    <div id='links'>
        <a href='https://github.com/algorithmica-org/tg/edit/master/binary-search.md'>Редактировать</a>
        <a href='https://github.com/algorithmica-org/tg/commits/master/binary-search.md'>История</a>
    </div>
</div>
<div class="migration"><a href='https://ru.algorithmica.org/cs/'>Сайт переезжает.</a> Большинство статей уже перенесено на новую версию.<br>Скоро добавим автоматические переходы, но пока обновленную версию этой статьи можно найти там.</div>
<h1 id="бинарный-поиск">Бинарный поиск</h1>
<ul>
<li>Линейный поиск</li>
<li>Бинарный поиск</li>
<li>Бинарный поиск с вещественными числами</li>
<li>Поиск максимума выпуклой функции: тернарный поиск, бинарный поиск</li>
<li>Бинарный поиск по ответу</li>
</ul>
<h2 id="линейный-поиск">Линейный поиск</h2>
<p>Мы считаем, что вы уже знаете линейный поиск, а именно умеете решать задачи такого типа:</p>
<ul>
<li>Проверить, есть ли в массиве число X</li>
<li>Найти максимум в массиве</li>
<li>Найти сумму чисел в массиве</li>
<li>Найти первое четное число в массиве</li>
</ul>
<p>Все такие задачи решаются с помощью одного прохода по массиву с помощью цикла for. Все такие алгоритмы работают за <span class="math inline">\(O(n)\)</span>. И даже можно понять, что быстрее, чем <span class="math inline">\(O(n)\)</span> решить ни одну из этих задач не получится.</p>
<h3 id="задание">Задание</h3>
<p>Убедитесь, что вы умеете решать эти задачи. Докажите, что быстрее, чем O(n) их решить в худшем случае нельзя.</p>
<h2 id="бинарный-поиск-1">Бинарный поиск</h2>
<p>Однако иногда найти число X в массиве можно и быстрее! Для этого надо добавить условие на то, что массив <strong>отсортирован</strong>. Но давайте начнем не с этого.</p>
<h3 id="задание-1">Задание</h3>
<p>Я загадал число X от 1 до 100. Вы можете спрашивать, больше ли мое число чем число T, я отвечаю “да” или “нет”. За сколько вопросов в худшем случае вы сможете найти число X? Как нужно действовать?</p>
<p><strong>Решение</strong> и состоит в идее бинарного (двоичного) поиска - нужно первым вопросом спросить “число X больше, чем 50?”. После этого, если ответ “нет”, надо спросить “число X больше, чем 25”? И так далее, нужно уменьшать отрезок возможных значений в два раза каждый раз.</p>
<p>Почему нужно делить обязательно пополам? Почему бы не спросить “число X больше, чем 80?” первым же вопросом? Но если вдруг ответ “нет”, то мы останемся с 80 вариантами вместо 100. То есть деление отрезка ровно пополам гарантирует, что в худшем случае мы останемся не более чем с половиной вариантов.</p>
<p>Чтобы понять, как быстро это работает, введём новую математическую функцию. Логарифмом по основанию <span class="math inline">\(a\)</span> от <span class="math inline">\(b\)</span> будем называть число <span class="math inline">\(c\)</span>, такое что <span class="math inline">\(a ^ c = b\)</span>. Обозначается как <span class="math inline">\(\log_a b = c\)</span>. Чаще всего мы будем работать с двоичным логарифмом, то есть в какую степень <span class="math inline">\(c\)</span> нужно возвести двойку, чтобы получить <span class="math inline">\(b\)</span>. Поэтому договоримся, что запись <span class="math inline">\(\log n\)</span> означает двочный логарифм <span class="math inline">\(n\)</span>.</p>
<p>Теперь вернёмся к нашей задаче. Можно понять, что такой алгоритм работает как раз за <span class="math inline">\(O(\log n)\)</span> вопросов (если число 100 на заменить абстрактную переменную <span class="math inline">\(n\)</span>). Несложно убедиться, что именно логарифм раз нужно поделить число на два, чтобы получилось 1.</p>
<h3 id="общий-принцип">Общий принцип</h3>
<p>А теперь представьте такую задачу: у вас есть массив, состоящий из некоторого количества подряд идущих нулей, за которыми следует какое-то количество подряд идущих единиц.</p>
<pre><code>a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]
n = len(a)
n</code></pre>
<pre><code>14</code></pre>
<p>Вам дан массив, и вам нужно найти позицию первой единицы, то есть найти такое место, где заканчиваются нули, и начинаются единицы. Это можно сделать с помощью линейного поиска за один проход по массиву, но хочется сделать это быстрее.</p>
<p>Давайте обратимся к идее <strong>бинарного поиска</strong>. Посмотрим на элемент посередине массива. Если это нуль, то первую единицу стоит искать в правой половину массива, а если единица - то в левой.</p>
<p>Есть много способов писать бинарный поиск, и в его написании люди очень часто путаются. Очень удобно в данном случае воспользоваться <strong>инвариантом</strong> (это слово значит “постоянное свойство”):</p>
<p><strong>Пусть переменная <code>left</code> всегда указывает на <span class="math inline">\(0\)</span> в массиве, а переменная <code>right</code> всегда указывает на <span class="math inline">\(1\)</span> в массиве</strong>.</p>
<p>Дальше мы будем переменные <code>left</code> и <code>right</code> постепенно сдвигать друг к другу, и в какой-то момент они станут соседними числами. Это и будет означать, что мы нашли место, где заканчиваются нули и начинаются единицы.</p>
<p>Чему равны <code>left</code> и <code>right</code> изначально, когда мы ничего про массив не знаем? Первая приходящая в голову идея - поставить их на <span class="math inline">\(0\)</span> и <span class="math inline">\(n-1\)</span> соответственно. Увы, в общем случае это может быть неверно, потому что <code>a[0]</code> может быть единицей, а <code>a[n-1]</code> может быть нулём. Правильнее сделать вот так:</p>
<pre><code>left = -1
right = n</code></pre>
<p>То есть изначально <code>left</code> и <code>right</code> указывают на несуществующие индексы. Но это нормально - например в массиве <code>[1, 1, 1, 1]</code> в конце алгоритма как раз должно быть <code>left == -1</code>, <code>right == 0</code>.</p>
<p>Осталось нам написать цикл <code>while</code>:</p>
<pre><code>while right - left &gt; 1:
    middle = (left + right) // 2 # именно такая формула для среднего индекса между left и right
    if a[middle] == 1:
        right = middle # right всегда должна указывать на 1
    else:
        left = middle # left всегда должна указывать на 0
print left, right
print a[left], a[right]</code></pre>
<pre><code>8 9
0 1</code></pre>
<p>Мы решили задачу для ноликов и единичек, но это легко обобщается на абсолютно любую задачу, где есть какое-то <strong>свойство, которое в начале массива не выполняется, а потом выполняется</strong>.</p>
<p>Например, если мы хотим найти, есть ли число <span class="math inline">\(X\)</span> в отсортированном массиве, то мы просто представим, что <span class="math inline">\(0\)</span> - это числа, меньшие <span class="math inline">\(X\)</span>, а <span class="math inline">\(1\)</span> - это числа, большие или равные <span class="math inline">\(X\)</span>. Тогда достаточно найти первую “единицу” и проверить, равно ли это число <span class="math inline">\(X\)</span>.</p>
<pre><code>a = [1, 3, 4, 10, 10, 10, 11, 80, 80, 81] # отсортированный массив
def bin_search(a, x):
    n = len(a)
    left = -1
    right = n
    while right - left &gt; 1:
        middle = (left + right) // 2
        if a[middle] &gt;= x: # практически единственная строка, которая меняется от задачи к задаче
            right = middle
        else:
            left = middle
    if right != n and a[right] == x: # ответ лежит в right
        return True
    else:
        return False

print (bin_search(a, 1))
print (bin_search(a, 10))
print (bin_search(a, 20))
print (bin_search(a, 79))
print (bin_search(a, 80))
print (bin_search(a, 81)</code></pre>
<pre><code>True
True
False
False
True
True</code></pre>
<h3 id="задание-2">Задание</h3>
<p>Придумайте, как с помощью бинарного поиска решить такие задачи: * Найти первое число, равное X в отсортированном массиве, или вывести, что таких чисел нет * Найти последнее число, равное X в отсортированном массиве, или вывести, что таких чисел нет * Посчитать, сколько раз встречается число X в отсортированном массиве (в решении помогают два предыдущих пункта) * Дан массив чисел, первая часть состоит из нечетных чисел, а вторая - из четных. Найти индекс, начиная с которого все числа четные.</p>
<p>Все эти задачи решаются бинарным поиском за <span class="math inline">\(O(\log{n})\)</span>. Правда нужно понимать, что в чистом виде такую задачу решать двоичным поиском бессмысленно - ведь чтобы создать массив размера <span class="math inline">\(n\)</span>, уже необходимо потратить <span class="math inline">\(O(n)\)</span> операций.</p>
<p>Поэтому зачастую такие задачи сформулированы таким образом:</p>
<p><strong>Дан отсортированный массив размера <span class="math inline">\(n\)</span>. Нужно ответить на <span class="math inline">\(m\)</span> запросов вида “встречается ли число <span class="math inline">\(x_i\)</span> в массиве n”?</strong></p>
<h3 id="задание-3">Задание</h3>
<p>Найдите время работы, за которое решается эта задача?</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p><strong>Решение</strong>: Такая задача решается за <span class="math inline">\(O(n + m\log{n})\)</span> - нужно создать массив за <span class="math inline">\(O(n)\)</span> и <span class="math inline">\(m\)</span> раз запустить бинарный поиск.</p>
<h3 id="задание-4">Задание</h3>
<p>Решите 3 первые задачи в этом контесте:</p>
<p>https://informatics.msk.ru/moodle/mod/statements/view.php?id=33216</p>
<h3 id="бинарный-поиск-с-вещественными-числами">Бинарный поиск с вещественными числами</h3>
<p>У нас все еще есть функция f(x), которая сначала равна 0, а потом равна 1, и мы хотим найти это место, где она меняет значение. Но теперь аргумент функции - вещественное число. Например: * <span class="math inline">\(f(x) = 1\)</span>, если <span class="math inline">\(x^2 &gt; 2\)</span> * <span class="math inline">\(f(x) = 0\)</span>, если <span class="math inline">\(x^2 \leq 2\)</span></p>
<p>Понятно, что при <span class="math inline">\(x = \sqrt 2\)</span> <span class="math inline">\(f(x) = 0\)</span>, а при любом даже немного большем значении <span class="math inline">\(f(x) = 1\)</span>. Если мы научимся решать такую задачу, то мы научимся находить корень из двух!</p>
<p>Увы, возникает проблема: <strong>действительные числа хранятся в компьютере неточно</strong></p>
<pre><code># известный пример
0.1 + 0.1 + 0.1</code></pre>
<pre><code>0.30000000000000004</code></pre>
<p>Тем более не сможем найти точное значение <span class="math inline">\(\sqrt 2\)</span>, потому что это бесконечная непериодическая дробь. Так что давайте снова воспользуемся бинарным поиском, причем всегда <span class="math inline">\(f(left) = 0\)</span>, <span class="math inline">\(f(right) = 1\)</span>, и мы остановимся тогда, когда <code>left</code> и <code>right</code> будет очень-очень близко.</p>
<p>И тут снова возникает проблема. Помимо того, что бесконечную дробь в принципе невозможно точно хранить в компьютере, ещё и арифметические операции понижают эту точность. Поэтому, чтобы явно не использовать разность между правым и левым указателем, можно задать фиксированное число шагов, которое будет выполняться.</p>
<p>Так как мы знаем, что <strong>двоичный</strong> поиск работает за <strong>двоичный</strong> логарифм, можно сказать, что на угадывание десятичного разряда числа потребуется примерно три шага бинпоиска (т. к. $  $). Значит, например, если нам нужно посчитать значение функции до шести знаков после запятой, то нам нужно ещё примерно 18 шагов уже после того, как расстояние между <code>left</code> и <code>right</code> достигло одного.</p>
<p>Чтобы каждый раз об этом не думать, можно считать, что ста шагов бинпоиска хватит для почти любых разумных целей.</p>
<pre><code>left = 0.0 # 0^2 &lt; 2, а значит f(0) = 0
right = 10.0 # 10^2 &gt; 2, а значит f(10) = 1
for i in range(100):
    middle = (left + right) / 2 # теперь деление не нацело, а вещественное
    if middle ** 2 &gt; 2:
        right = middle # right всегда должна указывать на 1
    else:
        left = middle # left всегда должна указывать на 0
print left, right
print left ** 2, right ** 2</code></pre>
<pre><code>1.41421356237 1.41421356237
2.0 2.0</code></pre>
<p>Вот мы и нашли корень из 2 с достаточно высокой точностью.</p>
<p>На самом деле, <strong>так можно искать ноль любой непрерывной функции </strong>(мы сейчас искали ноль функции <span class="math inline">\(x^2 - 2\)</span>)<strong>, у которой вы знаете значение меньше нуля и значение больше нуля</strong>.</p>
<h3 id="задание-5">Задание</h3>
<p>Придумайте, как с помощью вещественного бинпоиска найти * <span class="math inline">\(\sqrt[\leftroot{-2}\uproot{2}17]{1000}\)</span> * какой-нибудь корень уравнения <span class="math inline">\(x^4 + 3x = 5\)</span></p>
<h2 id="поиск-максимума-выпуклой-функции-тернарный-поиск-бинарный-поиск">Поиск максимума выпуклой функции: тернарный поиск, бинарный поиск</h2>
<p>Так мы только что научились находить корень непрерывной функции, у которой мы знаем значение меньше и больше 0. Но можно ли найти с помощью бинарного поиска локальный максимум функции? Можно!</p>
<p>Как известно, локальный максимум функции <span class="math inline">\(f\)</span> - это просто такое <span class="math inline">\(x_0\)</span>, что для всех близких к нему <span class="math inline">\(x\)</span> значения <span class="math inline">\(f(x) &lt; f(x_0)\)</span>. Для непрерывных функций выполняется более крутая вещь: слева от максимума функция возрастает, а справа от максимума функция убывает. Так это как раз отличное условие для нашего вещественного бинарного поиска!</p>
<p>Если вы знаете <span class="math inline">\(x_1\)</span> такое, что в его окрестности f(x) возрастает, и <span class="math inline">\(x_2\)</span> такое, что в его окрестности f(x) убывает, то можно запустить между ними бинпоиск и найти точку <span class="math inline">\(x_0\)</span> такую, что слева от нее возрастает значение функции, а справа - убывает. Это и есть локальный максимум.</p>
<p>А если функция выпуклая, то она вообще выглядит красиво: сначала возрастает, потом максимум, потом убывает.</p>
<p>Проблема только в одном: как по точке понять, в ее окрестности значение функции убывает или возрастает? Достаточно тыкнуть две точки очень-очень рядом с ней и сравнить их значения!</p>
<h3 id="задание-6">Задание</h3>
<p>Придумайте, как с помощью вещественного бинпоиска найти * максимум функции <span class="math inline">\(x - e^x\)</span> (она выпуклая, и максимум ровно один) * какой-нибудь локальный максимум функции <span class="math inline">\(31x+x^3-x^4\)</span></p>
<h3 id="тернарный-поиск">Тернарный поиск</h3>
<p>Другой способ искать максимум - это тернарный поиск. Пусть известно, что максимум находится между left и right. Поделим отрезок на <strong>три</strong> равные части: * middle_left = (2 * left + right) / 3 * middle_right = (left + 2 * right) / 3</p>
<p>Тогда если f(middle_left) &lt; f(middle_right), то можно спокойно заменить left на middle_left (максимум точно не левее middle_left), а если f(middle_left) &gt; f(middle_right), то можно спокойно заменить right на middle_right. Он будет работать не за двоичный логарифм, а за логарифм по основанию полтора, что больше (но асимптотически то же самое, так как отличается в константу раз).</p>
<p>Оба способа работают быстро, и обобщаются на дискретный случай (то, что было в начале - когда дан массив, значения в котором сначала возрастают, а потом убывают). Но проблема есть в том, что <strong>если функция нестрого возрастает и нестрого убывает, а именно если там есть отрезки постоянства, то алгоритм не работает</strong>. В случае, когда значения функции равны, никак нельзя понять, с какой стороны искать максимум - он может быть с любой стороны.</p>
<h3 id="задание-7">Задание</h3>
<p>Решите 4 и 5 задачи в этом контесте:</p>
<p>https://informatics.msk.ru/moodle/mod/statements/view.php?id=33216</p>
<h3 id="бинарный-поиск-по-неотсортированному-массиву">Бинарный поиск по неотсортированному массиву</h3>
<p>Заметьте, что в первоначальной задаче условие на то, что сначала идут нули, а потом идут единицы несущественно. Главное, чтобы мы знали индекс, который показывает на 0, и индекс, который показывает на 1. После этого бинарным поиском мы таким же способом найдем пару соседних нуля и единицы в массиве.</p>
<p>Поэтому бинарный поиск работает и не для возрастающих массивов / функций, если наша задача состоит именно в поиске двух соседних индексов, в которых условие выполняется и не выполняется.</p>
<p>Например, если мы знаем, что <span class="math inline">\(f(x_0) &lt; 0\)</span> и <span class="math inline">\(f(x_1) &gt; 0\)</span>, и функция непрерывная, то бинарным поиском можно найти ноль этой функции между <span class="math inline">\(x_0\)</span> и <span class="math inline">\(x_1\)</span>, даже если функция не монотонная!</p>
<p>Или, например, если нужно в массиве найти соседние четное и нечетное числа, и известно положение какого-то четного числа и какого-то нечетного числа, то это тоже можно легко сделать с помощью бинарного поиска.</p>
<p>Полезно иметь это в виду, это применяется в нескольких задачах контестов.</p>
<h2 id="бинарный-поиск-по-ответу">Бинарный поиск по ответу</h2>
<p>Рассмотрим такую задачу:</p>
<h3 id="пример-корова-в-стойла">Пример: “Корова в стойла”</h3>
<p><strong>Условие:</strong> На прямой расположены N стойл (даны их координаты на прямой), в которые необходимо расставить K коров так, чтобы минимальное расcтояние между коровами было как можно больше. Гарантируется, что <span class="math inline">\(1 &lt; K &lt; N\)</span>.</p>
<p><strong>Решение: </strong></p>
<p>Если решать задачу в лоб, то вообще неясно что делать. Нужно решать <strong>обратную</strong> задачу: давайте предположим, что мы знаем это расстояние X, ближе которого коров ставить нельзя. Тогда сможем ли мы расставить самих коров?</p>
<p>Ответ - да, можно ставить их довольно просто: самую первую ставим в самое левое стойло, это всегда выгодно. Следующие несколько стойл надо оставить пустыми, если они на расстоянии меньше X. В самое левое стойло из оставшихся надо поставить вторую корову и так далее. Даже ясно как это писать: надо идти слева направо по отсортированному массиву стойл, хранить координату последней коровы, и либо пропускать стойло, либо ставить в него новую корову.</p>
<p>То есть если мы знаем расстояние X, то мы можем за O(n) проверить, можно ли расставить K коров на таком расстоянии. Ну так давайте запустим бинпоиск по X, ведь при слишком маленьком X коров точно можно расставить, а при слишком большом - нельзя, и как раз эту границу и просят найти в задаче (“как можно больше”).</p>
<p>Осталось точно определить границы, то есть изначальные значения <em>left</em> и <em>right</em>. Нам точно хватит расстояния 0, так как гарантируется, что коров меньше, чем стойл. И точно не хватит расстояния max_coord - min_coord + 1, так как по условию есть хотя бы 2 коровы.</p>
<pre><code>coords = [2, 5, 7, 11, 15, 20] # координаты стойл
k = 3 # число коров

def is_correct(x): # проверяем, можно ли поставить K коров в стойла, если между коровами расстояние хотя бы x
    cows = 1
    last_cow = coords[0]
    for c in coords:
        if c - last_cow &gt;= x:
            cows += 1
            last_cow = c
    return cows &gt;= k

left = 0 # расставить коров на расстоянии хотя бы 0 можно всегда
right = max(coords) - min(coords) + 1 # при таком расстоянии даже 2 коровы поставить нельзя
while right - left != 1:
    middle = (left + right) // 2
    if is_correct(middle): # проверяем, можно ли поставить K коров в стойла, если между коровами расстояние хотя бы middle
        left = middle # left всегда должна указывать на ситуацию, когда можно поставить коров
    else:
        right = middle # right всегда должна указывать на ситуацию, когда нельзя поставить коров
print left # left - максимальное расстояние, на котором можно расставить коров в стойла</code></pre>
<pre><code>9</code></pre>
<h3 id="общий-принцип-1">Общий принцип</h3>
<p>Такой метод и называется <strong>бинпоиск по ответу</strong>. Он очень важный и очень распространен на олимпиадах, очень рекомендую решать на него задачи.</p>
<p>По сути мы просто взяли задачу “найдите максимальное X, такое что какое-то свойство от X выполняется” и решили её бинпоиском. Самое сложное - увидеть такую формулировку в задаче. Поэтому рассмотрим еще один пример.</p>
<h3 id="пример-очень-легкая-задача">Пример: “Очень Легкая Задача”</h3>
<p><strong>Условие:</strong> есть два принтера, один печатает лист раз в <span class="math inline">\(x\)</span> минут, другой раз в <span class="math inline">\(y\)</span> минут. За сколько минут они напечатают <span class="math inline">\(N\)</span> листов? <span class="math inline">\(N &gt; 0\)</span></p>
<p><strong>Решение</strong>: Здесь, в отличие от предыдущей задачи, кажется, существует прямое решение с формулой. Но вместо того, чтобы о нем думать, можно просто свести задачу к обратной. Давайте подумаем, как по числу минут <span class="math inline">\(T\)</span> (ответу) понять, сколько листов напечатается за это время? Очень легко: <span class="math display">\[\lfloor\frac{T}{x}\rfloor + \lfloor\frac{T}{y}\rfloor\]</span></p>
<p>Ясно, что за <span class="math inline">\(0\)</span> минут <span class="math inline">\(N\)</span> листов распечатать нельзя, а за <span class="math inline">\(xN\)</span> минут один только первый принтер успеет напечатать <span class="math inline">\(N\)</span> листов. Поэтому <span class="math inline">\(0\)</span> и <span class="math inline">\(xN\)</span> - это подходящие первые границы для бинарного поиска.</p>
<p><strong>Примечание:</strong> заметьте, что задача в контесте немного отличается! Прочитайте внимательно условие.</p>
<h3 id="задание-8">Задание</h3>
<p>Решите как можно больше задач в практическом контесте:</p>
<p>https://informatics.msk.ru/mod/statements/view.php?id=34097</p>
<p>Там могут встречаться задачи как на бинпоиск по ответу, так и на тернарный поиск по ответу.</p>
</body>
</html>
