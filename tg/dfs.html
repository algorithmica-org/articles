<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Графы — определения, деревья, хранение и поиск в глубину - Tinkoff Generation</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />

  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->

  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/tg/'><div id='logo'>Tinkoff Generation</div></a>
    <div id='links'>
        <a href='https://github.com/algorithmica-org/tg/edit/master/dfs.md'>Редактировать</a>
        <a href='https://github.com/algorithmica-org/tg/commits/master/dfs.md'>История</a>
    </div>
</div>
<div class="migration"><a href='https://ru.algorithmica.org/cs/'>Сайт переезжает.</a> Большинство статей уже перенесено на новую версию.<br>Скоро добавим автоматические переходы, но пока обновленную версию этой статьи можно найти там.</div>
<h1 id="графы-определения-деревья-хранение-и-поиск-в-глубину">Графы — определения, деревья, хранение и поиск в глубину</h1>
<h2 id="основные-определения">Основные определения</h2>
<p>Формальное определение:</p>
<p>Графом <span class="math inline">\(G\)</span> называется пара множеств <span class="math inline">\(G = (V, E\)</span>, где <span class="math inline">\(V(G)\)</span> — непустое конечное множество элементов, называемых <strong>вершинами</strong> графа, а <span class="math inline">\(E\)</span> — множество пар элементов из <span class="math inline">\(V\)</span> (необязательно различных), называемых <strong>ребрами</strong> графа. <span class="math inline">\(E = \{(u , v)\ | u, v \in V\}\)</span> — множество ребер графа <span class="math inline">\(G\)</span>, состоящее из пар вершин <span class="math inline">\((u, v)\)</span>. Ребро <span class="math inline">\((u, v)\)</span> соединяет вершины <span class="math inline">\(u\)</span> и <span class="math inline">\(v\)</span>.</p>
<p>Простое определение:</p>
<p>Граф - это набор вершин (точек) и соединяющих их отрезков (рёбер).</p>
<figure>
<img src="http://i.imgur.com/vE0aVrE.jpg" alt="Примеры графа" /><figcaption aria-hidden="true">Примеры графа</figcaption>
</figure>
<p>Две вершины, соединенные ребром, называют смежными вершинами. Обычно в задачах <span class="math inline">\(N\)</span> - количество вершин, а <span class="math inline">\(M\)</span> - ребер. Количество ребер, исходящее из вершины называют степенью вершины <span class="math inline">\(d(v)\)</span>. Для вершины <span class="math inline">\(a\)</span> ребро <span class="math inline">\((a, b)\)</span> называется инцидентным ей. На рисунке ниже вершине 8 инцидентно только ребро (4, 8), а вершине 10 ребра (2, 10) и (5, 10).</p>
<h3 id="теоретическое-задание">Теоретическое задание</h3>
<p>Назовите степень 1-ой и 6-ой вершины и какие ребра инциденты им.</p>
<figure>
<img src="http://gaskley.narod.ru/Discr/more_2/10.gif" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>Если какие-то две вершины соединены более, чем одним ребром, то говорят, что граф содержит кратные ребра. Если ребро соединяет вершину саму с собой, то такое ребро называют петлей.</p>
<p><strong>Простой граф</strong> не содержит петель и кратных ребер. Если не сказано ничего про наличие петель и кратных ребер, мы будем всегда считать, что граф простой.</p>
<h3 id="теоретическое-задание-1">Теоретическое задание</h3>
<p>Сколько может быть рёбер в простом графе в <span class="math inline">\(N\)</span> вершинами?</p>
<figure>
<img src="http://rain.ifmo.ru/cat/data/theory/unsorted/matroids-2004/graph.gif" alt="2" /><figcaption aria-hidden="true">2</figcaption>
</figure>
<h3 id="теоретическое-задание-2">Теоретическое задание</h3>
<p>Найдите цикл размера 4 и петлю в этом непростом графе.</p>
<p>Также часто рассматривают <strong>ориентированные графы</strong> — это графы, у которых ребра имеют направление, а иначе граф – неориентированный.</p>
<pre><code></code></pre>
<h2 id="хранение-графа-в-программе">Хранение графа в программе</h2>
<p>Чаще всего в задачах по программмированию вершины графа - это числа от <span class="math inline">\(0\)</span> до <span class="math inline">\(N-1\)</span>, чтобы удобно было обращаться к ним как к индексам в разных массивах.</p>
<p>Также чаще всего вам дают считать граф как просто список всех рёбер в нем (но не всегда, конечно). Как оптимально считать и сохранить граф? Есть 3 способа.</p>
<p>Для графа существуют несколько основных способов хранения:</p>
<ol type="1">
<li><strong>Матрица смежности.</strong> Давайте хранить двумерную матрицу <span class="math inline">\(A_{nn}\)</span>, где для данного графа G верно, что если <span class="math inline">\(A_{ij}\)</span> = 1, то две вершины <span class="math inline">\(i\)</span> и <span class="math inline">\(j\)</span> являются смежными, иначе вершины <span class="math inline">\(i\)</span> и <span class="math inline">\(j\)</span> смежными не являются.</li>
</ol>
<figure>
<img src="http://www.compendium.su/informatics/ege_1/ege_1.files/image026.jpg" alt="Граф G и Матрица смежности" /><figcaption aria-hidden="true">Граф G и Матрица смежности</figcaption>
</figure>
<p>Мы храним для каждой из <span class="math inline">\(N\)</span> вершин информацию, есть ли ребро в другие вершины, то есть суммарно мы храним <span class="math inline">\(N^2\)</span> ячеек, а следовательно асимптотика по памяти - <span class="math inline">\(O(N^2)\)</span>.</p>
<ol start="2" type="1">
<li><strong>Список смежности.</strong> Давайте для каждой из <span class="math inline">\(N\)</span> вершин хранить все смежные с ней, для этого нам потребуется любая динамическая структура, например vector в с++.</li>
</ol>
<pre><code>// как сделать список по матрице
vector&lt;vector&lt;int&gt; &gt; g(n);
for (int i = 0; i &lt; n; ++i){
    for (int j = 0;j &lt; n;++j){
        cin &gt;&gt; a;
        if (a) g[i].push_back(j);
    }
}
// список по списку ребер
cin &gt;&gt; n &gt;&gt; m;
vector&lt;vector&lt;int&gt; &gt; g(n);
for (int i = 0; i &lt; m; ++i){
  cin &gt;&gt; v1 &gt;&gt; v2;
  g[v1].push_back(v2);
  g[v2].push_back(v1);
}</code></pre>
<p>Здесь асимптотика по памяти и времени считывания - <span class="math inline">\(O(N + M)\)</span>, так как мы храним для каждой вершины, куда есть ребра, то есть <span class="math inline">\(2 M\)</span> ребер, а также суммарно <span class="math inline">\(N\)</span> векторов.</p>
<p>Плотные графы, имеющие большое количество ребер следует хранить при помощи матрицы смежности, а разреженные графы, имеющие малое количество ребер, оптимальнее при помощи списка.</p>
<ol start="3" type="1">
<li><strong>Список рёбер</strong>. Иногда граф явно вообще не требуется, а хватает хранить просто список ребер, который нам дают на вход.</li>
</ol>
<p>Заметьте, что все эти способы обощаются на случай ориентированных графов - при этом матрица смежности становится неориетированной: если есть ребро из вершины <span class="math inline">\(i\)</span> в вершину <span class="math inline">\(j\)</span>, то сделаем <span class="math inline">\(A_{ij} = 1\)</span>, а <span class="math inline">\(A_{ji} = 0\)</span>, если только нет обратного ребра тоже. А в списке смежности в ориентированном случае при считывании ребра <span class="math inline">\((u, v)\)</span> будем добавлять только <span class="math inline">\(v\)</span> в список соседей <span class="math inline">\(u\)</span>, но не наоборот.</p>
<h3 id="практическое-задание">Практическое задание</h3>
<p>Для окончательного закрепления темы советую решить первые 2 задачи.</p>
<h2 id="деревья">Деревья</h2>
<p>Дерево - это <strong>связный неориентированный граф без циклов</strong>.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/Tree_graph.svg/162px-Tree_graph.svg.png" alt="Пример дерева" /><figcaption aria-hidden="true">Пример дерева</figcaption>
</figure>
<p>Свойства дерева:</p>
<ol type="1">
<li>У дерева с хотя бы 2 вершинами всегда есть <strong>висячая вершина</strong> - вершина степени 1.</li>
</ol>
<p>Действительно, если начать из любой вершины идти по непосещенным ранее вершинам, то в какой-то момент мы прекратим это делать, ведь граф конечный. При этом если из этой вершины не может быть ребер в непосещенные вершины - ведь тогда прекращать рано, и не может быть ребер в посещенные ребра (помимо предыдущей) - ведь тогда есть цикл. А значит, есть ребро только в предыдущую вершину, значит степень равна 1.</p>
<ol start="2" type="1">
<li>У дерева с хотя бы 2 вершинами всегда есть две висячие вершины.</li>
</ol>
<p>Действительно, если предыдущий алгоритм начать из висячей вершины, то мы уткнемся в другую висячую вершину.</p>
<ol start="3" type="1">
<li>У дерева с <span class="math inline">\(N\)</span> вершинами всегда ровно <span class="math inline">\(N-1\)</span> ребро.</li>
</ol>
<p>Давайте отрезать от дерева его висячие вершины - при этом число вершин уменьшится на один, число ребер тоже уменьшится на один, а граф останется деревом. Раз граф остается деревом, у него все время будет висячая вершина, пока <span class="math inline">\(N &gt; 1\)</span>. В какой-то момент останется только одна вершина и ноль ребер. Раз мы отрезали столько же вершин, сколько ребер, и получили 1 вершину и 0 ребер, значит изначально вершин было ровно на одну больше.</p>
<ol start="4" type="1">
<li>Между любыми двумя вершинами в дереве есть ровно один простой путь.</li>
</ol>
<p>Действительно, если их два, то в графе есть цикл. Быть ноль их не может - ведь граф связный.</p>
<ol start="5" type="1">
<li>Дерево - это минимальный по числу рёбер связный граф на <span class="math inline">\(N\)</span> вершинах.</li>
</ol>
<p>Действительно, если есть связный граф, в котором меньше, чем <span class="math inline">\(N-1\)</span> ребро, то давайте уберем из его цикла ребро. Граф при этом остается связным, а число ребер уменьшается. Давайте повторять это, пока в какой-то момент циклов в графе не будет, а значит осталось дерево. Но мы уже доказали, что в дереве <span class="math inline">\(N-1\)</span> ребро, это противоречие, ведь у нас сначала было меньше ребер, а мы еще и удалили сколько-то.</p>
<h2 id="dfs-алгоритм-обхода-графа-в-глубину">DFS (Алгоритм обхода графа в глубину)</h2>
<p>Обход в глубину — простой, но многофункциональный алгоритм обхода графа по ребрам. Самое главное, что он может — это проверить, какие вершины достижимы из данной.</p>
<p>При обходе графа мы используем вспомогательный массив used, в котором храним 1, если вершина была посещена или 0 иначе. В начале мы считаем, что все вершины не использовались, затем мы выбираем одну вершину, помечаем ее посещенной и запускаемся рекурсивно из всех ее соседей, тогда мы посетим все вершины, которые достижимы из данной, если же остались вершины с used = 0 значит они недостижимы.</p>
<p>Красивая визуализация: https://visualgo.net/en/dfsbfs</p>
<pre><code>void dfs (int v) {
  used[v] = 1;
  for (auto to : g[v]) {
      if (!used[to]) {
          dfs(to);
      }
  }
}</code></pre>
<p>Давайте оценим сложность алгоритма. Так как мы проверяем, что вершина еще не использовалась, то всего мы пройдет каждую вершину 1 раз, но при этом и ребро между двумя вершинами, мы рассматриваем только когда рассматривается один конец, то есть мы просмотрим каждое ребро не более одного раза, суммарно получаем оценку <span class="math inline">\(O(N + M)\)</span>.</p>
<h3 id="практическое-задание-1">Практическое задание</h3>
<p>Задачи 3-5 в контесте.</p>
<h2 id="поиск-компонент-связности-графа">Поиск компонент связности графа</h2>
<p>Путем в графе называется последовательность вершин <span class="math inline">\(v_i \in 𝑉\)</span>, <span class="math inline">\(i = 1...k\)</span> таких, что две последовательные вершины в пути соединены ребром, <span class="math inline">\(k\)</span> - длина пути. Граф называется связным, если для любых двух его вершин существует путь между ними. Граф всегда можно разбить на непересекающиеся связные подмножества (возможно одно), между которыми рёбер нет, они называются компонентами связности.</p>
<p>Поиск в глубину dfs будет обходить ту компоненту связности, из вершины которой, он был вызван. Поэтому для поиска компонент связности можно каждый раз вызываться из любой непосещенной вершины и тогда в результате мы посетим все вершины, а следовательно и найдем все компоненты связности.</p>
<h1 id="граф-с-тремя-компонентами-связности"><img src="http://lib.vvsu.ru/books/Bakalavr01/obj.files/image726.gif" alt="Граф с тремя компонентами связности" /></h1>
<pre><code>for (int i = 0; i &lt; n; ++i){
    if (!used[i]) {
        amount++;
        dfs(i);
    }
}</code></pre>
<h3 id="практическое-задание-2">Практическое задание</h3>
<p>На данную тему задачи 6 и 10 в контесте.</p>
<h2 id="остовное-дерево">Остовное дерево</h2>
<p>Остованым деревом в связном графе называется любое подмножество ребер, которое является деревом на всех вершинах. То есть любой способ выкинуть несколько ребер так, чтобы осталось дерево на N вершинах и N-1 ребро выделяет в графе остовное дерево.</p>
<p>Обход графа удобно использовать для выделения этого остовного дерева - <strong>если выделить каждое ребро, по которому мы прошли в обходе, то получится остовное дерево</strong>. Действительно, мы обойдем все вершины, и при этом никогда не пойдем в вершину, в которой уже были, поэтому циклов там не будет. Так что достаточно после прохода по любому ребру добавлять его в ответ.</p>
<h3 id="практическое-задание-3">Практическое задание</h3>
<p>7 задача в контесте на выделение остовного дерева в графе.</p>
<h2 id="раскраска-графа-в-два-цвета">Раскраска графа в два цвета</h2>
<p>Корректной раскраской графа в два цвета назывется такая раскраска, что никакое ребро не соединяет две вершины одного цвета. Графы, которые можно так раскрасить, называют еще <strong>двудольными</strong>.</p>
<p>С помощью обхода графа легко проверить граф на двудольность и даже вывести цвет каждой вершины - достаточно выделить каждую.</p>
<h3 id="практическое-задание-4">Практическое задание</h3>
<p>8 задача в контесте на раскраску графа в два цвета</p>
<h2 id="поиск-циклов-в-графе">Поиск циклов в графе</h2>
<p>Циклом в графе <span class="math inline">\(G\)</span> называется ненулевой путь, ведущий из вершины <span class="math inline">\(v\)</span> в саму себя. Граф называют ацикличным, если в нем нет циклов.</p>
<p>В обычном dfs мы используем два цвета (1 - вершина посещена, 0 - не посещена), если же нам надо найти цикл, то давайте хранить 3 цвета:</p>
<ul>
<li>0 - вершина не просмотрена</li>
<li>1 - мы входили DFS-ом в эту вершину, но еще не вышли (а значит из нее есть путь до текущей),</li>
<li>2 - мы входили DFS-ом в эту вершину</li>
</ul>
<p>Заметим, что цикл будет тогда и только тогда, когда мы пытаемся войти в вершину с цветом 1.</p>
<pre><code>void dfs (int v) {
    used[v] = 1;
    for (size_t i=0; i &lt; g[v].size(); ++i) {
        int to = g[v][i];
        if (used[to] == 0){
            p[to] = v;
            dfs (to);
        }
        else if (used[to] == 1 &amp;&amp; to != p[v]) {
            cycle = true;
        }
    }
    used[v] = 2;
}</code></pre>
<p>В неориентированном графе также надо дополнительно рассмотреть случай, когда мы идем в предка - это циклом все-таки не считается, для этого нужно отдельно добавить второй аргумент prev, где хранить предыдущую вершину в dfs, и никогда не идти в неё.</p>
<h3 id="практическое-задание-5">Практическое задание</h3>
<p>9 задача в контесте на поиск цикла в графе.</p>
<p>#Ссылка на контест</p>
<p>https://informatics.msk.ru/mod/statements/view3.php?id=33377</p>
</body>
</html>
