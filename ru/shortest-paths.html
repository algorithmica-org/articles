<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Кратчайшие пути в графе - Алгоритмика</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />

  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->

  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/ru/'><div id='logo'>Алгоритмика</div></a>
    <div id='links'>
        <a href='https://github.com/algorithmica-org/ru/edit/master/shortest-paths.md'>Редактировать</a>
        <a href='https://github.com/algorithmica-org/ru/commits/master/shortest-paths.md'>История</a>
    </div>
</div>
<div class="migration"><a href='https://ru.algorithmica.org/cs/'>Сайт переезжает.</a> Большинство статей уже перенесено на новую версию.<br>Скоро добавим автоматические переходы, но пока обновленную версию этой статьи можно найти там.</div>
<h1 id="кратчайшие-пути-в-графе">Кратчайшие пути в графе</h1>
<p>Рассмотрим <strong>взвешенный граф</strong>, то есть у всех его ребер есть вес - некоторое число. Можно представить, что это цена, за которую мы можем по нему проехать.</p>
<p>Как его хранить? Давайте просто в списке смежности вместо номеров вершин соседа хранить пару (номер соседа, вес ребра до него).</p>
<p>Давайте решать задачу посика кратчайшего пути в графе - мы хотим за наименьшую стоимость проехать из вершины <span class="math inline">\(A\)</span> в <span class="math inline">\(B\)</span>.</p>
<p>Обычно будем считать, что в графе нет циклов отрицательного веса - иначе кратчайшее расстояниие может быть равно минус бесконечности.</p>
<p>Для данной задачи есть несколько алгоритмов решения.</p>
<h1 id="алгоритм-флойда">Алгоритм Флойда</h1>
<p>Мы с вами уже знаем динамическое программирование, давайте рассмотри следующую динамику:</p>
<p><span class="math inline">\(d_{i j}^k\)</span> - это длина кратчайшего пути от вершины <span class="math inline">\(i\)</span> до <span class="math inline">\(j\)</span>, используя как промежуточные только вершины из первых <span class="math inline">\(k\)</span> = <span class="math inline">\(d_{i j}^k\)</span> (напоминает рюкзак).</p>
<p>База динамики (<span class="math inline">\(k = 0\)</span>) определяется только путями из одного ребра. Если есть ребро из <span class="math inline">\(i\)</span> в <span class="math inline">\(j\)</span> стоимостью <span class="math inline">\(c\)</span>, то <span class="math inline">\(d_{i j}^{0}\)</span> = <span class="math inline">\(c\)</span>. Если таких ребер несколько, то, конечно, надо взять минимум.</p>
<p>Если мы хотим посчитать <span class="math inline">\(d_{i j}^{k}\)</span>, то у нас есть два варианта</p>
<ol type="1">
<li><p>Не брать на пути нигде <span class="math inline">\(k\)</span>-ую вершину, тогда <span class="math inline">\(d_{i j}^{k}\)</span> = <span class="math inline">\(d_{i j}^{k - 1}\)</span></p></li>
<li><p>Взять где-нибудь в пути k-ую вершину, тогда путь разбивается на две части - от <span class="math inline">\(i\)</span> до <span class="math inline">\(k\)</span> и от <span class="math inline">\(k\)</span> до <span class="math inline">\(j\)</span>, раз итоговый путь кратчайший, то и и эти два пути должны быть кратчайшми, а значит формула <span class="math inline">\(d_{i j}^{k}\)</span> = <span class="math inline">\(d_{i k}^{k - 1}\)</span> + <span class="math inline">\(d_{k j}^{k - 1}\)</span></p></li>
</ol>
<p>В результате ответ - <span class="math inline">\(d_{A B}^{n}\)</span>,</p>
<p>Можете подумать, как по такой динамике восстановить сам путь.</p>
<p>Также заметим, что вместо трехмерной динамики в этом алгоритме можно использовать двухмерную, храня в <span class="math inline">\(dp_{ij}\)</span> последнее известное значение из <span class="math inline">\(dp_{ij}^0\)</span>, <span class="math inline">\(dp_{ij}^1\)</span> <span class="math inline">\(dp_{ij}^2\)</span>, <span class="math inline">\(\ldots\)</span>, <span class="math inline">\(dp_{ij}^n\)</span>.</p>
<pre><code>for(int k = 0; k &lt; n; k++){
    for(int i = 0; i &lt; n; i++){
        for(int j = 0; j &lt; n; j++){
            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);
        }
    }
}</code></pre>
<h3 id="теоретическое-задание">Теоретическое задание</h3>
<p>Подумайте, как находить циклы отрицательного веса с помощью Флойда.</p>
<p>Плюсы алгоритма в том, что он находит расстояние сразу от всех вершин графа до остальных, а минус - алгоритм работает за <span class="math inline">\(O(N^3)\)</span>;</p>
<h3 id="практическое-задание">Практическое задание</h3>
<p>Первые две задачи на алгоритм Флойда.</p>
<h1 id="алгоритм-дейкстры">Алгоритм Дейкстры</h1>
<p>Для этого алгоритма придется рассматривать только графы без отрицательных рёбер.</p>
<p>Алгоритм Дейкстры решает немного другую задачу: он находит расстояние от <strong>одной</strong> вершины <span class="math inline">\(A\)</span> до <strong>каждой</strong> вершины. Давайте для каждой вершины хранить расстояние до нее из вершины <span class="math inline">\(A\)</span> в массиве <span class="math inline">\(d\)</span>. Например: * <span class="math inline">\(d[A] = 0\)</span> * <span class="math inline">\(d[x] = \infty\)</span>, если x не достижима из A</p>
<p>Назовем <strong>релаксацией</strong> обновление ответа для вершины <span class="math inline">\(b\)</span> через ребро <span class="math inline">\((a, b, c)\)</span> таким способом: <span class="math inline">\(d[b] = \min(d[b], d[a] + c)\)</span>.</p>
<ul>
<li>При таком действии ответ не может стать лучше, чем кратчайшее расстояние до <span class="math inline">\(b\)</span>, так как мы просто пользуемся путем для вершины <span class="math inline">\(a\)</span> и продлеваем его в <span class="math inline">\(b\)</span>.</li>
<li>Если мы прорелаксировали все ребра в кратчайшем пути в правильном порядке до вершины <span class="math inline">\(b\)</span>, то мы получим кратчайший путь до <span class="math inline">\(b\)</span>.</li>
</ul>
<p>Теперь давайте каждый раз доставать вершину, для которой расстояние от А сейчас минимально, и мы еще ее не смотрели и затем обновлять всех ее соседей. Допустим вершина с минимальным расстоянием - x, тогда надо прорелаксировать все ребра из нее.</p>
<p>Давайте докажем корректность алгоритма по индукции:</p>
<p>База) Первой вершиной мы всегда рассмотрим <span class="math inline">\(A\)</span>, но для нее верно, что расстояние от <span class="math inline">\(А\)</span> до <span class="math inline">\(А\)</span> = 0;</p>
<p>Шаг) Мы достали вершину <span class="math inline">\(i\)</span>, нам известно, что для всех ее предков ответ - корректен, но тогда, допустим, что для <span class="math inline">\(i\)</span>-ой вершины мы нашли ответ больший, чем надо, тогда это значит, что мы должны прийти из еще не рассмотренной вершины, но так как ребер отрицательного веса в графе нет, то такое невозможно <span class="math inline">\(\Rightarrow\)</span> мы доказали</p>
<p>https://visualgo.net/en/sssp?slide=1</p>
<p>Есть две возможные реализации алгоритма</p>
<ol type="1">
<li>реализация помощью нахождения минимального расстояния внутри массива за линию. Так как мы для каждого шага находим минимальную вершину, то мы сделаем не более <span class="math inline">\(N\)</span> шагов, но при этом на каждом шаге мы находим минимум за линию, то есть алгоритм работает за <span class="math inline">\(O(N^2)\)</span>.</li>
</ol>
<pre><code>for (int i = 0; i &lt; n; ++i){
    int uk = -1;
    for (int j = 0; j &lt; n; j++){
        if ((mark[j] == 0) &amp;&amp; ((uk == -1) || (d[j] &lt; d[uk]))){
                uk = j;
        }
    }
    for (int j = 0; j &lt; n; j++){
        if ((j != uk) &amp;&amp; (g[uk][j] != -1)) d[j] = min(d[j], g[uk][j] + d[uk]);
    }
    mark[uk] = 1;
}</code></pre>
<ol start="2" type="1">
<li>Реализация за <span class="math inline">\(O(MlognN + NlogN)\)</span> с помощью нахождения минимального расстояния внутри кучи/сета за логарифм. Так как для каждой вершины мы сделаем не более одного извлекания из структуры + каждое ребро мы используем максимум два раза. Для этого давайте в выбранной структуре хранить пару (расстояние, вершина); Первый код реализован с set, второй с кучей. Так как в куче нет компаратора на возрастание, то надо либо сделать свой, либо домножить расстояние на -1;</li>
</ol>
<pre><code>while (used.size()) {
    int v = (*(used.begin())).second;
    for (int i = 0; i &lt; g[v].size(); i++) {
        int to = g[v][i].first, c = g[v][i].second;
        if (dist[v] + c &lt; dist[to]) {
            used.erase({dist[to], to});
            dist[to] = dist[v] + to;
            used.insert({dist[to], to});
        }
    }
    used.erase({dist[v], v});
}</code></pre>
<pre><code>while (!q.empty()) {
        int v = q.top().second;
        q.pop();
    for (int j = 0; j &lt; g[v].size(); ++j) {
        int to = g[v][j].first, c = g[v][j].second;
        if (d[v] + c &lt; d[to]) {
            d[to] = d[v] + c;
            q.push({-d[to], to});
        }
    }
}</code></pre>
<h3 id="из-асимптотики-понятно-что-при-большом-количестве-ребер-первый-алгоритм-писать-лучше-иначе-второй.">Из асимптотики понятно, что при большом количестве ребер первый алгоритм писать лучше, иначе второй.</h3>
<h3 id="теоретическое-задание-1">Теоретическое задание</h3>
<p>Приведите примеры, когда каждый из алгоритмов работает лучше.</p>
<p>Недостаток алгоритма Дейкстры всего один - он не работает, если в графе есть ребра отрицательного веса.</p>
<h3 id="практическое-задание-1">Практическое задание</h3>
<p>3-5 Задача на алгоритм Дейкстры.</p>
<h1 id="форд-беллман">Форд-Беллман</h1>
<p>Этот алгоритм решает ту же задачу, что и Дейкстра, но зато может работать с отрицательными ребрами!</p>
<p>Давайте заведем массив расстояний, как и в дейкстре, для стартовой вершины расстояние = 0. Алгоритм состоит в <strong>релаксации каждого ребра в графе</strong> <span class="math inline">\(N-1\)</span> раз.</p>
<p>Это работает потому, что в кратчайшем пути не больше, чем <span class="math inline">\(N-1\)</span> ребро, и если мы прорелаксируем их в таком порядке, этот путь найдется. После <span class="math inline">\(N-1\)</span> прохода по всем ребрам и их релаксации мы точно это сделаем и найдем кратчайший путь.</p>
<p>Также в этом случае удобнее хранить <strong>список ребер</strong> явно вместо списка смежности.</p>
<pre><code>int from[m], to[m], cost[m];
for (int i = 0; i &lt; n - 1; ++i) {
        for (int j = 0; j &lt; m; ++j) {
                d[to[j]] = min(d[to[j]], d[from[j]] + cost[j]);
    }
}</code></pre>
<h3 id="теоретическое-задание-2">Теоретическое задание</h3>
<p>Подумайте, как найти цикл отрицательного веса с помощью этого алгоритма.</p>
<h3 id="практическое-задание-2">Практическое задание</h3>
<p>Решите задачи 6 и 7.</p>
<h1 id="ссылка-на-контест">Ссылка на контест</h1>
<p>https://informatics.msk.ru/mod/statements/view.php?id=33380#1</p>
</body>
</html>
