<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Корневая оптимизация - Алгоритмика</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />

  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->

  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/ru/'><div id='logo'>Алгоритмика</div></a>
    <div id='links'>
        <a href='https://github.com/algorithmica-org/ru/edit/master/sqrt.md'>Редактировать</a>
        <a href='https://github.com/algorithmica-org/ru/commits/master/sqrt.md'>История</a>
    </div>
</div>
<div class="migration"><a href='https://ru.algorithmica.org/cs/'>Сайт переезжает.</a> Большинство статей уже перенесено на новую версию.<br>Скоро добавим автоматические переходы, но пока обновленную версию этой статьи можно найти там.</div>
<h1 id="корневая-оптимизация">Корневая оптимизация</h1>
<p>Корневые эвристики — это обобщённое название различных методов и структур данных, опирающихся на тот факт, что если мы разделим какое-то множество из <span class="math inline">\(n\)</span> элементов на блоки по <span class="math inline">\(\sqrt{n}\)</span> элементов, то самих этих блоков будет не более <span class="math inline">\(\sqrt{n}\)</span>.</p>
<p>Центральное равенство этой статьи: <span class="math inline">\(\sqrt x = \frac{x}{\sqrt x}\)</span>.</p>
<h2 id="корневая-декомпозиция-на-массивах">Корневая декомпозиция на массивах</h2>
<p>Сделаем вид, что про <a href="segtree">дерево отрезков</a> мы не знаем, и рассмотрим следующую задачу:</p>
<blockquote>
<p>Дан массив <span class="math inline">\(a\)</span> длины <span class="math inline">\(n\)</span> и <span class="math inline">\(q\)</span> запросов одного из двух типов:</p>
<ol type="1">
<li><p>Найти сумму на отрезке <span class="math inline">\([l, r]\)</span>.</p></li>
<li><p>Увеличить все элементы на отрезке [l, r] на <span class="math inline">\(x\)</span>.</p></li>
</ol>
</blockquote>
<p>Разделим весь массив на блоки по <span class="math inline">\(c \approx \sqrt{n}\)</span> элементов и посчитаем сумму на каждом блоке. Так как блоки не пересекаются, суммарно это будет работать за <span class="math inline">\(O(n)\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// c это и количество блоков, и также их размер; оно должно быть чуть больше корня</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> maxn <span class="op">=</span> <span class="fl">1e5</span><span class="op">,</span> c <span class="op">=</span> <span class="dv">330</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>maxn<span class="op">],</span> b<span class="op">[</span>c<span class="op">];</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add<span class="op">[</span>c<span class="op">];</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    b<span class="op">[</span>i <span class="op">/</span> c<span class="op">]</span> <span class="op">+=</span> a<span class="op">[</span>i<span class="op">];</span></span></code></pre></div>
<p>Заведем также массив <code>add</code> размера <span class="math inline">\(\sqrt n\)</span>, который будем использовать для отложенной операции прибавления на блоке. Будем считать, что реальное значение <span class="math inline">\(i\)</span>-го элемента равно <code>a[i]</code> + <code>add[i / c]</code>.</p>
<p>Теперь мы можем отвечать на запросы первого типа за <span class="math inline">\(O(\sqrt n)\)</span> на запрос:</p>
<ol type="1">
<li><p>Для всех блоков, лежащих целиком внутри запроса, просто возьмём уже посчитанные суммы и прибавим к ответу.</p></li>
<li><p>Для блоков, пересекающихся с запросом только частично (их два — правый и левый), проитерируемся по нужным элементам и прибавим к ответу.</p></li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> res <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;=</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// если мы находимся в начале блока и он целиком в запросе</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>l <span class="op">%</span> c <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> l <span class="op">+</span> c <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;=</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            res <span class="op">+=</span> b<span class="op">[</span>l <span class="op">/</span> c<span class="op">];</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            l <span class="op">+=</span> c<span class="op">;</span> <span class="co">// мы можем прыгнуть сразу на блок</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            res <span class="op">+=</span> a<span class="op">[</span>l<span class="op">]</span> <span class="op">+</span> add<span class="op">[</span>l <span class="op">/</span> c<span class="op">];</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            l <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Обновление пишется примерно так же:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> upd<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;=</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>l <span class="op">%</span> c <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> l <span class="op">+</span> c <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;=</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            b<span class="op">[</span>l <span class="op">/</span> c<span class="op">]</span> <span class="op">+=</span> c <span class="op">*</span> x<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>            add<span class="op">[</span>l <span class="op">/</span> c<span class="op">]</span> <span class="op">+=</span> x<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            l <span class="op">+=</span> c<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            a<span class="op">[</span>l<span class="op">]</span> <span class="op">+=</span> x<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            l<span class="op">++;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a> <span class="op">}</span></span></code></pre></div>
<p>Обе операции будут работать за <span class="math inline">\(O(\sqrt n)\)</span>, потому что нужных «центральных» блоков всегда не более <span class="math inline">\(\sqrt n\)</span>, а в граничных блоках суммарно не более <span class="math inline">\(2 \sqrt n\)</span> элементов.</p>
<h2 id="корневая-эвристика-на-запросах">Корневая эвристика на запросах</h2>
<p>Сделаем вид, что запросов обновления нет. Тогда бы мы решали это задачу просто массивом префиксных сумм.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> s<span class="op">[</span>maxn<span class="op">];</span> <span class="co">// [0, r)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>s<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    s<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> s<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> a<span class="op">[</span>i<span class="op">];</span></span></code></pre></div>
<p>Подойдём теперь к задаче с другой стороны: разобьём на корневые блоки не массив, а запросы к нему. Будем обрабатывать каждый блок запросов независимо от других с помощью массива префикных сумм, который мы будем честно пересчитывать каждые <span class="math inline">\(\sqrt q\)</span> запросов.</p>
<p>На каждый запрос суммы мы можем потратить <span class="math inline">\(O(1)\)</span> времени на запрос к префиксным суммам, плюс <span class="math inline">\(\sqrt q\)</span> времени на поправку на всех запросах из буфера.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> query <span class="op">{</span> <span class="dt">int</span> l<span class="op">,</span> r<span class="op">,</span> x<span class="op">;</span> <span class="op">};</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>query<span class="op">&gt;</span> buffer<span class="op">;</span> <span class="co">// запросы, не учтенные в префиксных суммах</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> res <span class="op">=</span> s<span class="op">[</span>r <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">-</span> s<span class="op">[</span>l<span class="op">];</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>query q <span class="op">:</span> buffer<span class="op">)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// пересечем запрос суммы со всеми запросами</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        res <span class="op">+=</span> q<span class="op">.</span>x <span class="op">*</span> max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> min<span class="op">(</span>r<span class="op">,</span> q<span class="op">.</span>r<span class="op">)</span> <span class="op">-</span> max<span class="op">(</span>l<span class="op">,</span> q<span class="op">.</span>l<span class="op">));</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rebuild<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> d<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// массив дельт</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>query q <span class="op">:</span> buffer<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        d<span class="op">[</span>q<span class="op">.</span>l<span class="op">]</span> <span class="op">+=</span> x<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        d<span class="op">[</span>q<span class="op">.</span>r <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">-=</span> x<span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    buffer<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> delta <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> running_sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        p<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> running_sum<span class="op">;</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        delta <span class="op">+=</span> d<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        running_sum <span class="op">+=</span> delta<span class="op">;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> upd<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    buffer<span class="op">.</span>push_back<span class="op">({</span>l<span class="op">,</span> r<span class="op">,</span> x<span class="op">});</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>buffer<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> c<span class="op">)</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// буфер слишком большой; надо пересчитать префиксные суммы и очистить его</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        rebuild<span class="op">();</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Такое решение будет работать за <span class="math inline">\(O(n \sqrt q + q \sqrt q)\)</span>.</p>
<h3 id="превращение-статических-структур-в-динамические">Превращение статических структур в динамические</h3>
<p>Эту технику можно применять не только к массиву префиксных сумм, но и к любым статическим структурам данных.</p>
<blockquote>
<p>Требуется добавлять точки в выпуклую оболочку и уметь находить касательные (то есть находить точку, которая максимизирует скалярное произведение <span class="math inline">\(a_i x + b_i y\)</span>).</p>
</blockquote>
<p>Мы можем так же каждые <span class="math inline">\(\sqrt q\)</span> запросов перестраивать выпуклую оболочку, а при ответе на запрос касательной помимо кандидата из построенной выпуклой оболочки рассмотреть дополнительно <span class="math inline">\(\sqrt q\)</span> скалярных произведений из точек из буфера.</p>
<p>Теперь чуть сложнее:</p>
<blockquote>
<p>Требуется добавлять и <strong>удалять</strong> точки из выпуклой оболочки и уметь находить касательные. <strong>Запросы известны заранее.</strong></p>
</blockquote>
<p>Разобьём запросы на блоки явно, и будем обрабатывать их по отдельности. На каждом блоке построим выпуклую оболочку только тех точек, которые существуют на всём её блоке, а остальные запросы сохраним в буфер. При ответе на запрос касательной помимо кандидата из построенной оболочки будем рассматривать все точки, которые существуют на момент данного запроса — найти все такие точки можно за <span class="math inline">\(\sqrt q\)</span>, проанализировав историю текущего блока.</p>
<p>Часто, если удалений в задаче нет или их можно как-то эмулировать, можно применить похожую, но более мощную технику: поддерживать <span class="math inline">\(O(\log n)\)</span> структур (например, выпуклых оболочек) размеров степени двойки, причём так, что нет двух структур одинакового размера. При добавлении новой точки мы создаем для неё новую структуру размера 1. Дальше, если структура размера 1 уже существует, то мы объединяем эти две структуры и создаём структуру размера 2. Если структура размера 2 уже существовала, то мы объединяем её и создаём структуру размера 4, и так далее. Запрос мы будем передавать во все <span class="math inline">\(O(\log n)\)</span> базовых структур и объединять ответы.</p>
<h2 id="алгоритм-мо">«Алгоритм Мо»</h2>
<p>Обсудим еще одно решение этой же задачи: на этот раз будем группировать запросы и по временным, и по пространственным признакам. Пусть все запросы даны нам заранее, и запросов обновления нет. Опять же притворимся, что про префиксные суммы мы не слышали.</p>
<p>Сгруппируем все запросы в корневые блоки по их левой границе, внутри каждого блока отсортируем запросы по правой границе и будем обрабатывать каждый такой блок по отдельности. Будем проходиться по запросам блока, поддерживая сумму текущего отрезка. Для первого отрезка посчитаем сумму честно, а для всех остальных будем каждый раз сдвигать его границы и обновлять сумму — по одному элементу за раз.</p>
<p>Трюк в том, что правая граница суммарно сдвинется на <span class="math inline">\(O(n)\)</span>, потому что отрезки отсортированы, а левая — каждый раз на <span class="math inline">\(O(\sqrt n)\)</span>. Итоговая асимптотика решения будет <span class="math inline">\(O(q \sqrt n + n \sqrt n)\)</span>: изменение левых границ суммарно по всем блокам займёт <span class="math inline">\(O(q \sqrt n)\)</span> операций, а правых — <span class="math inline">\(O(n \sqrt n)\)</span>,</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> query <span class="op">{</span> <span class="dt">int</span> l<span class="op">,</span> r<span class="op">,</span> idx<span class="op">;</span> <span class="op">};</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">// idx -- это номер запроса, на который нужно ответить</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>maxn<span class="op">];</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>query<span class="op">&gt;</span> b<span class="op">[</span>c<span class="op">];</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ans<span class="op">[</span>maxq<span class="op">];</span> <span class="co">// массив ответов на запросы</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">// где-то в main:</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>query q <span class="op">:</span> queries<span class="op">)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    b<span class="op">[</span>q<span class="op">.</span>l <span class="op">/</span> c<span class="op">].</span>push_back<span class="op">(</span>q<span class="op">);</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> c<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>b<span class="op">[</span>i<span class="op">].</span>begin<span class="op">(),</span> b<span class="op">[</span>i<span class="op">].</span>end<span class="op">(),</span> <span class="op">[](</span>query a<span class="op">,</span> query b<span class="op">){</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">.</span>r <span class="op">&lt;</span> b<span class="op">.</span>r<span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> c<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l <span class="op">=</span> i <span class="op">*</span> c<span class="op">,</span> r <span class="op">=</span> i <span class="op">*</span> c <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// границы текущего отрезка</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> s <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// сумма на текущем отрезке</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>query q <span class="op">:</span> b<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>r <span class="op">&lt;</span> q<span class="op">.</span>r<span class="op">)</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>            s <span class="op">+=</span> a<span class="op">[++</span>r<span class="op">];</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;</span> q<span class="op">.</span>l<span class="op">)</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            s <span class="op">-=</span> a<span class="op">[</span>l<span class="op">++];</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>l <span class="op">&gt;</span> q<span class="op">.</span>l<span class="op">)</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>            s <span class="op">+=</span> a<span class="op">[--</span>l<span class="op">];</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">[</span>q<span class="op">.</span>idx<span class="op">]</span> <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Конкретно для этой задачи этот алгоритм не нужен, однако он полезен для ответа на более сложные вопросы: найти <span class="math inline">\(k\)</span>-ую порядковую статистику на отрезке, его медиану, количество различных элементов, наиболее часто встречающийся элемент и так далее. Во всех этих случаях нужно просто вместо суммы поддерживать какую-нибудь структуру — например, хэш-таблицу — отвечающую за множество элементов на отрезке, и пересоздавать её между блоками.</p>
<p><strong>Примечание.</strong> Алгоритм назван по имени какого-то неизвестного китайца и принят под этим названием в фольклоре ICPC. Автору это не нравится, но что поделать: другого названия не придумали.</p>
<h3 id="вариации">Вариации</h3>
<p><strong>На деревьях.</strong> В некоторых задачах требуется считать результаты операций на дереве. Например: рядом с каждой вершиной есть число, и нам нужно возвращать количества различных значений на путях.</p>
<p>Идея примерно такая же, как при <a href="lca">сведении LCA к RMQ</a>. Мы можем выписать эйлеров обход дерева (каждую вершину выписываем дважды — в моменты входа и выхода), и теперь задача сводится к задаче на массиве, только с одним исключением: мы должны добавлять в структуру только те элементы, которые содержатся на отрезке ровно 1 раз.</p>
<p><strong>Использовать корневую декомпозицию как структуру.</strong> Часто от внутренней структуры в алгоритме Мо требуется что-то сложное, и мы пребегаем к использованию каких-то «тяжелых» структур, вроде дерева отрезков. Но данный случай отличается от обычных задач на обработку запросов: у нас обновлений <span class="math inline">\(O(n \sqrt n)\)</span>, а запросов всего <span class="math inline">\(O(n)\)</span>. Здесь эффективнее вместо дерева отрезков, требующего <span class="math inline">\(O(\log n)\)</span> времени на оба типа запросов, взять структуру, которая быстро работает при обновлениях, и не очень быстро на самих запросах — например, корневую декомпозицию, которая работает за <span class="math inline">\(O(1)\)</span> и <span class="math inline">\(O(\sqrt n)\)</span> соответственно.</p>
<p>На самом деле, это примерно единственное место, где корневую эвристику как структуру использовать эффективнее всего — внутри другой корневой эвристики.</p>
<p><strong>«3D Мо».</strong> Если очень захотеть, этот подход можно применять и в задачах, где надо обрабатывать запросы обновления. Для этого нужно ввести третий параметр get-запроса <span class="math inline">\(t\)</span>, который будет равен числу update-запросов до текущего get.</p>
<p>Снова отсортируем все get-запросы, но на этот раз в порядке <span class="math inline">\((\frac{t}{n^{\frac 2 3}}, \frac{l}{n ^{\frac{2}{3}}}, r)\)</span>, и обработаем их таким же алгоритмом, только в трёх измерениях. Время работы нового подхода будет <span class="math inline">\(O(n^{\frac{5}{3}})\)</span>, что доказывается аналогично исходному алгоритму.</p>
<h2 id="деление-на-тяжелые-и-легкие-объекты">Деление на тяжелые и легкие объекты</h2>
<p>Всем известный алгоритм факторизации за корень опирается на тот факт, что каждому «большому» делителю <span class="math inline">\(d \geq \sqrt n\)</span> числа <span class="math inline">\(n\)</span> соответствует какой-то «маленький» делитель <span class="math inline">\(\frac{n}{d} \leq n\)</span>.</p>
<p>Подобное полезное свойство (что маленькие объекты маленькие, а больших объектов не много) можно найти и у других объектов.</p>
<h3 id="длинные-и-короткие-строки">Длинные и короткие строки</h3>
<p><a href="https://codeforces.com/contest/710/problem/F">710F. Операции над множеством строк</a>. Требутся в онлайне обрабатывать три типа операций над множеством строк:</p>
<ol type="1">
<li>Добавить строку в множество.</li>
<li>Удалить строку из множества.</li>
<li>Для заданной строки, найти количество её вхождений как подстроку среди всех строк множества.</li>
</ol>
<p>Одно из решений следующее: разделим все строки на <em>короткие</em> (<span class="math inline">\(|s| &lt; \sqrt l\)</span>) и <em>длинные</em> (<span class="math inline">\(|s| \geq \sqrt l\)</span>), где <span class="math inline">\(l\)</span> означает суммарную длину всех строк. Заметим, что длинных строк немного — не более <span class="math inline">\(\sqrt l\)</span>.</p>
<p>С запросами будем справляться так:</p>
<ul>
<li><p>Заведём хэш-таблицу, и когда будем обрабатывать запрос добавления или удаления, будем прибавлять или отнимать соответственно единицу по <a href="hashing">хэшам</a> всех её коротких подстрок. Это можно сделать суммарно за <span class="math inline">\(O(l \sqrt l)\)</span>: для каждой строки нужно перебрать <span class="math inline">\(O(\sqrt l)\)</span> разных длин и окном пройтись по всей строке.</p></li>
<li><p>Для запроса третьего типа для короткой строки, просто посчитаем её хэш и посмотрим на значение в хэш-таблице.</p></li>
<li><p>Для запроса третьего типа для длинной строки, мы можем позволить себе посмотреть на все неудалённые строки, потому что таких случаев будет немного, и если мы можем за линейное время найти все вхождения новой строки, то работать это будет тоже за <span class="math inline">\(O(l \sqrt l)\)</span>. Например, можно посчитать <a href="string-searching">z-функцию</a> для всех строк вида <span class="math inline">\(s\#t\)</span>, где <span class="math inline">\(s\)</span> это строка из запроса, а <span class="math inline">\(t\)</span> это строка из множества; здесь, правда, есть нюанс: <span class="math inline">\(s\)</span> может быть большой, а маленьких строк <span class="math inline">\(t\)</span> много — нужно посчитать z-функцию сначала только от <span class="math inline">\(s\)</span>, а затем виртуально дописывать к ней каждую <span class="math inline">\(t\)</span> и досчитывать функцию.</p></li>
</ul>
<p>Иногда отдельный подход к тяжелым и лёгким объектам не требуется, но сама идея помогает увидеть, что некоторые простые решения работают быстрее, чем кажется.</p>
<h3 id="треугольники-в-графе">Треугольники в графе</h3>
<p>Рассмотрим другую задачу:</p>
<blockquote>
<p>Дан граф из <span class="math inline">\(n\)</span> вершин и <span class="math inline">\(m \approx n\)</span> рёбер. Требуется найти в нём количество циклов длины три.</p>
</blockquote>
<p>Будем называть вершину <em>тяжелой</em>, если она соединена с более чем <span class="math inline">\(\sqrt n\)</span> другими вершинами, и <em>лёгкой</em> в противном случае.</p>
<p>Попытаемся оценить количество соединённых вместе троек вершин, рассмотрев все возможные 4 варианта:</p>
<ol start="0" type="1">
<li><p>В цикле нет тяжелых вершин. Рассмотрим какое-нибудь ребро <span class="math inline">\((a, b)\)</span> цикла. Третья вершина <span class="math inline">\(c\)</span> должна лежать в объединении списков смежности <span class="math inline">\(g_a\)</span> и <span class="math inline">\(g_b\)</span>, а раз обе эти вершины лёгкие, то таких вершин найдётся не более <span class="math inline">\(\sqrt n\)</span>. Значит, всего циклов этого типа может быть не более <span class="math inline">\(O(m \sqrt n)\)</span>.</p></li>
<li><p>В цикле одна тяжелая вершина. Аналогично — есть одно «лёгкое» ребро, а значит таких циклов тоже <span class="math inline">\(O(m \sqrt n)\)</span>.</p></li>
<li><p>В цикле две тяжелые вершины — обозначим их как <span class="math inline">\(a\)</span> и <span class="math inline">\(b\)</span>, а лёгкую как <span class="math inline">\(c\)</span>. Зафиксируем пару <span class="math inline">\((a, c)\)</span> — способов это сделать <span class="math inline">\(O(m)\)</span>, потому что всего столько рёбер. Для этого ребра будет не более <span class="math inline">\(O(\sqrt n)\)</span> рёбер <span class="math inline">\((a, b)\)</span>, потому что столько всего тяжелых вершин. Получается, что всего таких циклов может быть не более <span class="math inline">\(O(m \sqrt n)\)</span>.</p></li>
<li><p>Все вершины тяжелые. Аналогично — тип третьей вершины в разборе предыдущего случая нигде не использовался; важно лишь то, что тяжелых вершин <span class="math inline">\(b\)</span> немного.</p></li>
</ol>
<p>Получается, что циклов длины 3 в графе может быть не так уж и много — не более <span class="math inline">\(O(m \sqrt n)\)</span>.</p>
<p>Само решение максимально простое: отсортируем вершины графа по их степени, ориентируем ребра <span class="math inline">\(v \rightarrow u, v \le u\)</span>; теперь внутренним циклом будем перебирать пути <span class="math inline">\(v \rightarrow u \rightarrow w, v \le u \le w\)</span>, а потом проверять существование ребра <span class="math inline">\(v \rightarrow w\)</span>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> g<span class="op">[</span>maxn<span class="op">],</span> p<span class="op">(</span>n<span class="op">);</span> <span class="co">// исходный граф и список номеров вершин</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>iota<span class="op">(</span>p<span class="op">.</span>begin<span class="op">(),</span> p<span class="op">.</span>end<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// 0, 1, 2, 3, ...</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">// чтобы не копипастить сравнение:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> cmp <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g<span class="op">[</span>a<span class="op">].</span>size<span class="op">()</span> <span class="op">&lt;</span> g<span class="op">[</span>b<span class="op">].</span>size<span class="op">()</span> <span class="op">||</span> <span class="op">(</span>g<span class="op">[</span>a<span class="op">].</span>size<span class="op">()</span> <span class="op">==</span> g<span class="op">[</span>b<span class="op">].</span>size<span class="op">()</span> <span class="op">&amp;&amp;</span> a <span class="op">&lt;</span> b<span class="op">);</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">// в таком порядке мы будем перебирать вершины</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>sort<span class="op">(</span>p<span class="op">.</span>begin<span class="op">(),</span> p<span class="op">.</span>end<span class="op">(),</span> cmp<span class="op">);</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">// теперь удалим все лишние рёбра (ведущие в более тяжелые вершины)</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> v <span class="op">&lt;</span> n<span class="op">;</span> v<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>t <span class="op">=</span> g<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// отсортируем их и удалим какой-то суффикс</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>t<span class="op">.</span>begin<span class="op">(),</span> t<span class="op">.</span>end<span class="op">(),</span> cmp<span class="op">);</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>t<span class="op">.</span>size<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> cmp<span class="op">(</span>t<span class="op">.</span>back<span class="op">(),</span> v<span class="op">))</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        t<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    reverse<span class="op">(</span>t<span class="op">.</span>begin<span class="op">(),</span> t<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co">// рядом с каждой вершиной будем хранить количество</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co">// ранее просмотренных входящих рёбер (v -&gt; w)</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> cnt<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">:</span> g<span class="op">[</span>v<span class="op">])</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        cnt<span class="op">[</span>w<span class="op">]++;</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">:</span> g<span class="op">[</span>v<span class="op">])</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">:</span> g<span class="op">[</span>u<span class="op">])</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">+=</span> cnt<span class="op">[</span>w<span class="op">];</span> <span class="co">// если в графе нет петель, то cnt[w] это 0 или 1</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// при переходе к следующему v массив нужно занулить обратно</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">:</span> g<span class="op">[</span>v<span class="op">])</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>        cnt<span class="op">[</span>w<span class="op">]--;</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Задачу также можно было решить чуть более прямолинейно, переместив все проверки внутрь основного цикла, но это сказалось бы на скорости работы.</p>
<h3 id="рюкзак-за-os-sqrt-s">Рюкзак за <span class="math inline">\(O(S \sqrt S)\)</span></h3>
<p>Если у нас есть <span class="math inline">\(n\)</span> предметов с весами <span class="math inline">\(w_1\)</span>, <span class="math inline">\(w_2\)</span>, <span class="math inline">\(\ldots\)</span>, <span class="math inline">\(w_n\)</span>, такими что <span class="math inline">\(\sum w_i = S\)</span>, то мы можем решить задачу о рюкзаке за время <span class="math inline">\(O(S \cdot n)\)</span> стандартной динамикой. Чтобы решить задачу быстрее, попытаемся сделать так, чтобы число предметов <span class="math inline">\(n\)</span> стало <span class="math inline">\(O(\sqrt S)\)</span>.</p>
<p>Заметим, что количество различных весов среди будет <span class="math inline">\(O(\sqrt S)\)</span>, потому что если среди них есть <span class="math inline">\(k\)</span> различных чисел, то:</p>
<p><span class="math display">\[
S = w_1 + w_2 + \ldots + w_n \geq 1 + 2 + \ldots + k = \frac{k \cdot (k+1)}{2}
\]</span></p>
<p>Откуда значит, что <span class="math inline">\(k \leq 2\sqrt S\)</span>.</p>
<p>Рассмотрим теперь некоторый вес <span class="math inline">\(x\)</span>, который <span class="math inline">\(k\)</span> раз встречается в наборе весов. «Разложим» <span class="math inline">\(k\)</span> по степеням двойки и вместо всех <span class="math inline">\(k\)</span> вхождений этого веса добавим веса <span class="math inline">\(x\)</span>, <span class="math inline">\(2 \cdot x\)</span>, <span class="math inline">\(4 \cdot x\)</span>, <span class="math inline">\(\ldots\)</span>, <span class="math inline">\((c - 1 - 2^t) \cdot x\)</span>, где <span class="math inline">\(t\)</span> это максимальное целое число, для которого выполняется <span class="math inline">\(2^t − 1 \leq c\)</span>. Легко видеть, что все суммы вида <span class="math inline">\(q \cdot x\)</span> (<span class="math inline">\(q \leq k\)</span>) и только их по-прежнему можно набрать.</p>
<p>Алгоритм в этом и заключается — проведем данную операцию со всеми уникальными значениями весов и после чего запустим стандартное решение. Уже сейчас легко видеть, что новое количество предметов будет <span class="math inline">\(O(\sqrt S \log S)\)</span>, потому что для каждого веса мы оставили не более <span class="math inline">\(\log S\)</span> весов, а всего различных весов было <span class="math inline">\(O(\sqrt S)\)</span>.</p>
<p><strong>Упражнение.</strong> Доказать, что предметов на самом деле будет <span class="math inline">\(O(\sqrt S)\)</span>.</p>
<p><strong>Примечание.</strong> Классическое решение рюкзака можно ускорить на несколько порядков, если использовать <a href="bitset">bitset</a> или <a href="sse">векторизовать</a> его основной цикл.</p>
<h2 id="бакеты">Бакеты</h2>
<p>Пусть нам нужно находить всё ту же сумму, но теперь у нас запрос обновления выглядит так: <span class="math inline">\(i\)</span>-тый элемент <em>прыгает</em> на <span class="math inline">\(d\)</span> позиций вправо или влево, смещая, соответственно, <span class="math inline">\(d\)</span> элементов между начальной и конечной позицией на единицу вправо или влево. Сумму нужно находить уже в новой индексации. Про <a href="treap">декартово дерево</a> автор снова просит читателя на время забыть.</p>
<p>Объединим предыдущие подходы: теперь не только будем делить массив на блоки <em>примерно</em> по корню, но и каждый корень запросов будем перестраивать всю структуру.</p>
<p>А именно, теперь мы будем работать не с чётко разделённые блоки, а с <em>корзинами</em> переменного размера, в которых хранятся небольшие массивы с элементами, а также сумма на всей корзине. До начала обработки запросов добавим в каждую из них примерно по <span class="math inline">\(\sqrt n\)</span> последовательных элементов.</p>
<p>При нахождении суммы мы будем действовать как раньше, а при запросе обновления найдём две нужные корзины (из какой корзины элемент удаляется и в какую добавляется) и полностью их пересоздадим — за их суммарный размер. Чтобы корзины не стали слишком большими, просто будем каждые <span class="math inline">\(\sqrt n\)</span> запросов их полностью перестраивать.</p>
<p>Такое подход всё ещё будет работать за <span class="math inline">\(O(m \sqrt n)\)</span>, но позволяет решать задачи, в которых меняется порядок элементов. Реальный пример: IOI 2011 «<a href="https://wcipeg.com/problem/ioi1122">Dancing Elephants</a>».</p>
<h2 id="подбор-константы">Подбор константы</h2>
<p>На скорость работы очень сильно влияет размер блока. Мы для простоты использовали одну и ту же константу и для количества блоков, и для их размера, но на практике их часто нужно подбирать.</p>
<p>Иногда асимптотики «тяжелой» и «лёгкой» части получаются разными, потому что мы где-то не смогли обойтись без какой-нибудь структуры, которая внесла лишний логарифм. Чаще всего, в качестве оптимального размера блока <span class="math inline">\(c^*\)</span> можно взять что-то близкое к решению уравнения <span class="math inline">\(g \cdot \frac{n}{c} = f \cdot c\)</span>, где <span class="math inline">\(f\)</span> и <span class="math inline">\(g\)</span> это асимптотики блочной и не-блочной частей соответственно.</p>
<p>Впрочем, надо также учитывать, что походы в какое-нибудь декартово дерево совсем не в логарифм раз медленнее линейного прохода по массиву.</p>
</body>
</html>
