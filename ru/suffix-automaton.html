<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Суффиксный автомат - Алгоритмика</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
  
     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->
  
  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/ru/'><div id='logo'>Алгоритмика</div></a>
    <div id='links'>
        <!--<a href='https://algorithmica.org/ru/'>На главную</a>-->
        <a href='https://github.com/algorithmica-org/articles/edit/master/src/ru/suffix-automaton.md'>Редактировать</a>
        <!--<a href='https://github.com/algorithmica-org/articles/commits/master/src/ru/suffix-automaton.md'>История изменений</a>-->
    </div>
</div>
<h1 id="суффиксный-автомат">Суффиксный автомат</h1>
<p>Если вы не знаете, что такое префиксное дерево или автомат, рекомендуется сначала почитать про Ахо-Корасик.</p>
<p>Рассмотрим задачу:</p>
<blockquote>
<p>Дан текст <span class="math inline">\(T\)</span> и <span class="math inline">\(n\)</span> строк <span class="math inline">\(s_i\)</span>, для каждой из которых нужно узнать, встречается ли она в тексте.</p>
</blockquote>
<p>Есть два основных подхода к решению этой задачи. Первый: алгоритм Ахо-Корасик, который строит по набору строк автомат, распознающий эти строки в потоке текста. Второй: использование суффиксных структур, под которыми обычно подразумневают суффиксный массив, суффиксный автомат или суффикское дерево.</p>
<p>Данная статья посвящена последним двум из них.</p>
<h2 id="наивное-решение">Наивное решение</h2>
<p>Возьмем все суффиксы <span class="math inline">\(T\)</span> и объединим их в бор, в котором каждой подстроке <span class="math inline">\(T\)</span> будет соответствовать ровно одна вершина. С его помощью можно за <span class="math inline">\(O(|T|^2)\)</span> времени на построение и <span class="math inline">\(O(|s_i|)\)</span> времени на запрос узнавать, входит ли <span class="math inline">\(s_i\)</span> в <span class="math inline">\(T\)</span>.</p>
<p>Идея дальнейшей оптимизации заключается в убирании «лишних» состояний в этом боре.</p>
<p>От квадратиченой сложности можно избавиться двумя разными способами — ведущими, соответственно, либо к суффиксному автомату, либо к суфффиксному дереву.</p>
<p><strong>Сжатое суффиксное дерево.</strong> Любой путь от корня в этом боре будет подстрокой <span class="math inline">\(T\)</span>, а значит, если из вершины <span class="math inline">\(v\)</span> нет исходящий рёбер, то можно заменить путь на ребро, храня рядом с ним всю строку. Непосредственно хранить строку при этом не обязательно — она есть где-то как подстрока <span class="math inline">\(T\)</span>, а значит можно просто хранить пару чисел <span class="math inline">\([l, r]\)</span>, указывающую на её местоположение.</p>
<p>Выясняется, что такая структура данных занимает <span class="math inline">\(O(|T|)\)</span> памяти. Чтобы это понять, нужно оценить количество «развилок» — мест, где путь разъеденяется на два.</p>
<p>Пусть мы бор строли путем добавления суффиксов. Тогда, каждая новая строка совпадала каким-то префиксом с уже имеющейся, а потом отпочковалась и породила новый путь. Получается, что вершин тут не больше, чем строк.</p>
<p>Сжатое суффиксное дерево тоже годится для нашей задачи: только теперь по рёбрам нужно шагать виртуально, просматривая один символ за другим.</p>
<p>Существуют алгоритмы, которые строят сжатое суффиксное дерево эффективно — например, алгортим Укконена. Мы их рассматривать в этой статье не будем и сразу перейдём ко второму методу.</p>
<p><strong>Суффиксным автоматом</strong> строки <span class="math inline">\(s\)</span> называется <em>минимальный</em> (с наименьшим количеством вершин) <em>детерминированный</em> (нет двух различных путей, соответствующих одинаковой строке) автомат, принимающий все различные подстроки <span class="math inline">\(s\)</span> и только их.</p>
<p>Выясняется, что он тоже маленький, и если хранить переходы в <code>std::map</code>, то автомат можно построить за <span class="math inline">\(O(n log k)\)</span> времени и <span class="math inline">\(O(n)\)</span> памяти, где <span class="math inline">\(k\)</span> — размер алфавита (обычно <span class="math inline">\(k\)</span> считают константой, и тогда построение происходит вообще за <span class="math inline">\(O(n)\)</span>).</p>
<p>Сперва обозначим основные свойства суффиксного автомата и его состояний, затем опишем алгоритм, а затем поймём, как и почему он работает.</p>
<p>Любое состояние <span class="math inline">\(V\)</span> автомата будет принимать некоторый набор строк <span class="math inline">\(T\)</span>, причём если отсортировать эти строки по возрастанию длины, то для любой строки <span class="math inline">\(s_i \in T (i &lt; |T|)\)</span> следующая по порядку строка - это <span class="math inline">\(s_{i+1} = cs_i\)</span> для некоторого символа <span class="math inline">\(c\)</span>. Исходя из определения суффиксного автомата, для любого префикса исходной строки <span class="math inline">\(S\)</span> существуют несколько состояний, принимающих его суффиксы: состояние <span class="math inline">\(V_1\)</span>, принимающее суффиксы длин от 1 до некоторого <span class="math inline">\(k_1\)</span>, состояние <span class="math inline">\(V_2\)</span>, принимающее суффиксы длин от <span class="math inline">\(k_1+1\)</span> до <span class="math inline">\(k_2\)</span>, и т.д. до состояния, принимающего самые длинные суффиксы данного префикса, включая сам префикс. Из каждого состояния <span class="math inline">\(X\)</span>, кроме корневого, существует <em>суффиксная ссылка</em>: пусть <span class="math inline">\(X\)</span> принимает некоторую строку <span class="math inline">\(p\)</span>, тогда суффиксная ссылка из <span class="math inline">\(X\)</span> ведёт в отличное от <span class="math inline">\(X\)</span> состояние, принимающее суффикс <span class="math inline">\(p\)</span> максимальной длины. Также из каждого состояния <span class="math inline">\(X\)</span>, кроме корневого, ведёт ещё одна ссылка, мы назовём её <em>префиксной</em>: пусть самая длинная принимаемая <span class="math inline">\(X\)</span> строка - это <span class="math inline">\(p\)</span>, тогда префиксная ссылка из <span class="math inline">\(X\)</span> указывает на состояние, принимающее префикс <span class="math inline">\(p\)</span> на единицу меньшей длины.</p>
<p>Теперь можем перейти к <strong>алгоритму построения суффиксного автомата</strong>. Наш алгоритм будет “индуктивным”: он будет перестраивать автомат, коррекно построенный для строки <span class="math inline">\(s\)</span>, получая из него автомат для строки <span class="math inline">\(sc\)</span>.</p>
<p>Предположим, что мы построили суффиксный автомат для строки <span class="math inline">\(s\)</span>, удовлетворяющий всем требованиям, и теперь добавляем символ <span class="math inline">\(c\)</span>. Пусть <span class="math inline">\(X\)</span> - состояние, которое принимало строку <span class="math inline">\(s\)</span> до добавления <span class="math inline">\(c\)</span>. Сперва мы обязаны создать новое состояние <span class="math inline">\(U\)</span>, так как появилась строка <span class="math inline">\(sc\)</span>, которая ранее не входила в <span class="math inline">\(s\)</span>. Затем, мы должны добавить переход из <span class="math inline">\(X\)</span> в <span class="math inline">\(U\)</span> по символу <span class="math inline">\(c\)</span> (потому что должно быть состояние, принимающее <span class="math inline">\(sc\)</span>). Таким образом, наше новое состояние <span class="math inline">\(U\)</span> теперь принимает некоторый набор суффиксов <span class="math inline">\(sc\)</span>. Перейдём по суффиксной ссылке из <span class="math inline">\(X\)</span>. Тогда есть два случая: 1. Перехода по <span class="math inline">\(c\)</span> из текущего состояния нет. Тогда мы можем и должны добавить переход по символу <span class="math inline">\(c\)</span>, ведущий в <span class="math inline">\(U\)</span>: теперь <span class="math inline">\(U\)</span> принимает ещё больший набор суффиксов. Снова перейдём по суффиксной ссылке из текущего состояния и продолжим пытаться строить переходы. 2. Переход по <span class="math inline">\(c\)</span> из текущего состояния есть. Таким образом, для оставшихся суффиксов <span class="math inline">\(sc\)</span> уже существовуют свои состояния, на этом моменте следует остановиться и перейти к следующей части алгоритма.</p>
<p>Опять есть два случая: первый - ни из одного состояния, в котором мы побывали, перехода по <span class="math inline">\(c\)</span> не нашлось, и в итоге мы перешли по суффиксной ссылке из корня “в никуда”. Тогда все суффиксы <span class="math inline">\(sc\)</span> принимаются одним состоянием <span class="math inline">\(U\)</span>, так что суффиксную ссылку из <span class="math inline">\(U\)</span> мы проведём в корень, префиксную - в <span class="math inline">\(X\)</span> - и завершим алгоритм.</p>
<p>Второй случай: в какой-то момент мы попали в состояние <span class="math inline">\(P\)</span>, из которого уже был переход по <span class="math inline">\(c\)</span>. Этот случай сложнее, и он также предполагает два возможных варианта. Обозначим за <span class="math inline">\(Q\)</span> состояние, в которое ведёт переход по символу <span class="math inline">\(c\)</span> из <span class="math inline">\(P\)</span>. Пусть самая длинная строка, принимаемая <span class="math inline">\(P\)</span> - это <span class="math inline">\(l\)</span>. Снова рассмотрим два случая: 1. Префиксная ссылка из <span class="math inline">\(Q\)</span> ведёт в <span class="math inline">\(P\)</span>. Это означает, что состояние <span class="math inline">\(Q\)</span>, как и все достижимые по суфф. ссылкам из <span class="math inline">\(Q\)</span> состояния, принимает только суффиксы <span class="math inline">\(sc\)</span>: исходя из определения префиксной ссылки, <span class="math inline">\(l\)</span> является самой длинной строкой, принимаемой <span class="math inline">\(Q\)</span>, с приписанным в конце символом <span class="math inline">\(c\)</span>, то есть суффиксом <span class="math inline">\(sc\)</span>, а все остальные строки, принимаемыми <span class="math inline">\(P\)</span>, являются суффиксами самой длинной. 2. Префиксная ссылка из <span class="math inline">\(Q\)</span> ведёт не в <span class="math inline">\(P\)</span>. Это означает, что существует строка, принимаемая <span class="math inline">\(Q\)</span>, длина которой больше, чем <span class="math inline">\(lc\)</span>; но такая строка если и является суффиксом <span class="math inline">\(sc\)</span>, то из одного из ранее посещённых (в первой части алгоритма) состояний есть переход по <span class="math inline">\(c\)</span> - противоречие; значит, <span class="math inline">\(Q\)</span> помимо суффиксов <span class="math inline">\(sc\)</span> также принимает строки, не являющиеся суффиксами <span class="math inline">\(sc\)</span>, что недопустимо. Поэтому мы должны сделать две версии <span class="math inline">\(Q\)</span>: одна принимает строки старого <span class="math inline">\(Q\)</span>, являющиеся суффиксами <span class="math inline">\(sc\)</span> - назовём их основным набором, а вторая - все остальные строки <span class="math inline">\(Q\)</span> - назовём их дополнительным набором. Для этого клонируем состояние <span class="math inline">\(Q\)</span>: создадим новое состояние <span class="math inline">\(Q&#39;\)</span>, которое будет отвечать за строки основного набора, скопируем в него все переходы, которые были в <span class="math inline">\(Q\)</span> и скопируем суффиксную ссылку из <span class="math inline">\(Q\)</span>. Префиксную ссылку из <span class="math inline">\(Q&#39;\)</span> проведём в <span class="math inline">\(P\)</span>. Состояние <span class="math inline">\(Q\)</span> теперь будет отвечать только за строки дополнительного набора, поэтому мы должны перенаправить его суффссылку в <span class="math inline">\(Q&#39;\)</span>. Суффиксная ссылка из <span class="math inline">\(U\)</span> также должна указывать на <span class="math inline">\(Q&#39;\)</span>, т.к. все суффиксы <span class="math inline">\(sc\)</span> большей длины уже принимаются <span class="math inline">\(U\)</span>. Осталось только перенаправить некоторые переходы, ведущие в <span class="math inline">\(Q\)</span>, на состояние <span class="math inline">\(Q&#39;\)</span>: заметим, что это будут в точности все переходы по <span class="math inline">\(c\)</span> в <span class="math inline">\(Q&#39;\)</span> из всех состояний, достижимых по суффиксным ссылкам из <span class="math inline">\(P\)</span>, включая <span class="math inline">\(P\)</span>.</p>
<p>Для строки длины 0 суффиксный автомат - это единственное, корневое состояние. Таким образом, мы получили корректный алгоритм построения суффиксного автомата.</p>
<h2 id="связь-между-суффиксным-автоматом-и-суффиксным-деревом">Связь между суффиксным автоматом и суффиксным деревом</h2>
<p>Рассмотрим ребро в суффиксном дереве строки <span class="math inline">\(T\)</span>, а точнее все подстроки <span class="math inline">\(T\)</span>, которым соответствует или “внутренняя” вершина ребра, или вершина, в которой ребро заканчивается. Для любой строки <span class="math inline">\(x\)</span> и любой пары строк <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> из рассматриваемого множества строк, строки <span class="math inline">\(xa\)</span> и <span class="math inline">\(xb\)</span> являются или не являются префиксами строки <span class="math inline">\(s\)</span> одновременно.</p>
<p>Пусть <span class="math inline">\(|a| &lt; |b|\)</span>. Тогда <span class="math inline">\(a\)</span> является предком <span class="math inline">\(b\)</span> в боре, то есть, её префиксом, значит, её множество вхождений точно содержит множество вхождений строки <span class="math inline">\(b\)</span>. Допустим, существует позиция <span class="math inline">\(|x|\)</span>, в которой есть вхождение строки <span class="math inline">\(a\)</span>, но не строки <span class="math inline">\(b\)</span>.</p>
<p>Рассмотрим строку <span class="math inline">\(a&#39;\)</span>, которая является максимальным префиксом строки <span class="math inline">\(b\)</span>, который можно встретить в той позиции. Если <span class="math inline">\(a&#39;\)</span> не упирается в конец строки, то её можно продолжить, как минимум, двумя различными символами чтобы она осталась подстрокой <span class="math inline">\(T\)</span>. Значит, соответствующая ей вершина в дереве имеет степень больше двух и должна разбивать ребро, на котором находится, что конфликтует с предположением о том, что <span class="math inline">\(a\)</span> и <span class="math inline">\(b\)</span> взяты с одного ребра.</p>
<p>Если же <span class="math inline">\(a&#39;\)</span> нельзя продолжить, то она всё ещё должна разбивать ребро, т.к. является суффиксом строки и её вершина не будет удалена при сжатии рёбер.</p>
<p>Аналогичным образом можно показать, что для любой строки <span class="math inline">\(a\)</span> все строки <span class="math inline">\(b\)</span> с таким же множеством строк <span class="math inline">\(x\)</span> находятся на соответствующем строке <span class="math inline">\(a\)</span> ребре, то есть, есть биекция между рёбрами суффиксного дерева и множествами левых позиций вхождений строк в <span class="math inline">\(T\)</span>. Отсюда:</p>
<p>Для любого состояния <span class="math inline">\(q\)</span> суффиксного автомата строки <span class="math inline">\(T\)</span> найдётся вершина <span class="math inline">\(q&#39;\)</span> суффиксного дерева развернутой строки <span class="math inline">\(T\)</span> такая, что множество строк, принимаемых состоянием <span class="math inline">\(q\)</span>, совпадает с развёрнутым множеством строк, таких что соответствующая им вершина в дереве лежит на ребре, ведущем в <span class="math inline">\(q&#39;\)</span> (включая строку, соответствующую <span class="math inline">\(q&#39;\)</span>).</p>
<p>Это целиком описывает состояния автомата и позволяет разработать алгоритм его построения. Код суффиксного автомата можно найти в конце статьи.</p>
<h1 id="время-работы">Время работы</h1>
<p>Достаточно очевидно, что вершин в автомате (и, соответственно, префиксных и суффиксных ссылок) не более <span class="math inline">\(2n\)</span> - действительно, для каждого символа добавляется ровно одно состояние и клонируется максимум одно. Переходов, очевидно, не более <span class="math inline">\(nk\)</span>, однако можем дать более строгую оценку сверху в <span class="math inline">\(3n\)</span>. Сплошных переходов - т.е. ведущих в состояние <span class="math inline">\(X\)</span> из состояния, достижимого по префиксной ссылке <span class="math inline">\(X\)</span> - не более <span class="math inline">\(2n\)</span>. Рассмотрим переходы, не являющиеся сплошными. Состояния, принимающие суффиксы строки, назовём терминальными. Каждому из оставшихся переходов поставим в соответствие строку <span class="math inline">\(t_{1}ct_{2}\)</span>, где <span class="math inline">\(c\)</span> - символ на ребре, <span class="math inline">\(t_1\)</span> - самая длинная строка, принимаемая “истоком” перехода, а <span class="math inline">\(t_2\)</span> - самая длинная строка, ведущая из “стока” перехода до некоторого терминального состояния. Заметим, что <span class="math inline">\(t_1\)</span> и <span class="math inline">\(t_2\)</span> образованы только сплошными переходами (т.к. если от одного состояния до другого есть некоторый путь, то есть не менее короткий путь, проходящий только по сплошным переходам). Также заметим, что во-первых, полученная строка будет являться некоторым суффиксом исходной, а во-вторых, так как все переходы кроме одного в таком пути сплошные, все такие строки будут различными. Из этих двух фактов следует, что количество несплошных переходов не более <span class="math inline">\(n\)</span>, так как у строки ровно <span class="math inline">\(n\)</span> суффиксов. Таким образом, переходов в автомате не более <span class="math inline">\(3n\)</span>, а ссылок не более <span class="math inline">\(4n\)</span>, то есть автомат линеен по памяти. По сути, доказав асимптотику по памяти, мы почти доказали время работы, и неочевидным остаётся только то, за сколько работает перенаправление переходов после клонирования. Заметим, что если мы добавляли символ <span class="math inline">\(c\)</span> и клонировали состояние <span class="math inline">\(Q\)</span> и получили <span class="math inline">\(Q&#39;\)</span>, то не может быть такого, что через какое-то время мы добавим символ <span class="math inline">\(c\)</span> и нам пришлось клонировать <span class="math inline">\(Q&#39;\)</span> и, соответственно, перенаправлять переходы по <span class="math inline">\(c\)</span>, ведущие в <span class="math inline">\(Q&#39;\)</span>. Доказательство: из <span class="math inline">\(P\)</span> обязательно есть переход по символу <span class="math inline">\(c\)</span> в <span class="math inline">\(Q&#39;\)</span>, причём этот переход сплошной, и такие переходы есть только из <span class="math inline">\(P\)</span> и некоторых достижимых из него по суффиксным ссылкам состояний. Также заметим, что для некоторого <span class="math inline">\(k \geq 0\)</span> и только для него из всех состояний, достижимых из <span class="math inline">\(P\)</span> за <span class="math inline">\(k\)</span> переходов по суффиксным ссылкам, будет существовать переход в <span class="math inline">\(Q&#39;\)</span>. Таким образом, ни один клон не будет клонирован повторно, а все остальные вершины будут клонированы максимум один раз, то есть каждый переход будет перенаправлен максимум один раз, а переходов линейное число, поэтому суммарно будет совершено <span class="math inline">\(O(n)\)</span> действий для перенаправления. Итак, мы доказали, что суффиксный автомат линеен по памяти и требует <span class="math inline">\(O(n log k)\)</span> времени на построение. TODO доказательство неверное</p>
<h1 id="применение-в-решении-задач">Применение в решении задач</h1>
<ol type="1">
<li><p><strong>Число различных подстрок.</strong> Дана строка <span class="math inline">\(s\)</span>, необходимо посчитать</p>
<p>количество её различных подстрок. В каждом состоянии встречаются</p>
<p>строки длины от <span class="math inline">\(len(link(q)) + 1\)</span> до <span class="math inline">\(len(q)\)</span>. Всего</p>
<p><span class="math inline">\(len(q) - len(link(q))\)</span> строк. Просуммировав эту величину по всем</p>
<p>состояниям, получим ответ.</p>
<p><em>Упражнение:</em> решите эту же задачу за <span class="math inline">\(O(n)\)</span>, учитывая, что к строке</p>
<p><span class="math inline">\(s\)</span> символы дописываются по одному и после каждого нового символа</p>
<p>необходимо сказать текущее число различных подстрок строки <span class="math inline">\(s\)</span>.</p>
<p><em>Упражнение*:</em> Возьмём задачу из предыдущего упражнения и скажем,</p>
<p>что теперь мы можем не только дописывать символы <em>в конец</em>, но и</p>
<p>удалять их <em>с начала</em> строки. Вам требуется отвечать на те же</p>
<p>запросы. Время работы решения всё ещё должно линейно зависеть от</p>
<p>размера входа. <em>Подсказка:</em> иногда алгоритм Укконена также бывает</p>
<p>полезен.</p></li>
<li><p><strong>Поиск подстрок в тексте.</strong> Пропустив строку через автомат мы</p>
<p>сможем сказать, входит ли она в текст. Допустим, мы хотим узнать</p>
<p>какую-то информацию о её вхождениях. Например, нам нужно выдать</p>
<p>любое конкретное вхождение. Как мы уже знаем, каждому вхождению</p>
<p>соответствует строка <span class="math inline">\(x\)</span> такая что <span class="math inline">\(ax\)</span> — суффикс <span class="math inline">\(s\)</span>. Или, проще</p>
<p>говоря, путь из состояния <span class="math inline">\(q\)</span> в какое-то финальное состояние.</p>
<p>Динамикой по автомату как ациклическому ориентированному графу мы</p>
<p>можем найти длину какого-нибудь такого пути (например, для</p>
<p>определённости минимального или максимального). Отметим, что</p>
<p>аналогичной динамикой считаются многие другие полезные значения,</p>
<p>например, количество строк в правом контексте состояния (или, что то</p>
<p>же самое, количество вхождений строк из состояния в <span class="math inline">\(s\)</span>).</p>
<p>Альтернативным решением будет обратиться к дереву суффиксных ссылок,</p>
<p>которое, как мы помним, является суффиксным деревом для <span class="math inline">\(s^T\)</span>. Как</p>
<p>мы упоминали в самом начале, любая подстрока строки <span class="math inline">\(s\)</span> является</p>
<p>префиксом одного из суффиксов исходной строки. Таким образом, если</p>
<p>мы запишем в каждую “суффиксную” вершину индекс соответствующего ей</p>
<p>суффикса, то все позиции вхождений строки <span class="math inline">\(t\)</span> в <span class="math inline">\(s\)</span> можно будет</p>
<p>обнаружить в поддереве вершины, которая соответствует строке <span class="math inline">\(t\)</span>.</p>
<p>Значит, в частности, динамикой можно будет найти самое первое или</p>
<p>самое последнее вхождение.</p>
<p>Более того, учитывая, что в последнем случае мы работали с деревом,</p>
<p>мы можем обойти его таким образом, чтобы на каждом шаге иметь в</p>
<p>вершине множество возможных позиций, в которых встречаются строки из</p>
<p>соответствующего состояния. Для этого нужно применить идею быстрого</p>
<p>слияния множеств, когда мы всегда добавляем элементы из меньшего</p>
<p>множества в большее, а не наоборот. Тогда такой обход потребует</p>
<p><span class="math inline">\(O(n \log n)\)</span> операций добавления в множество, т.к. каждый раз когда</p>
<p>мы переносим между множествами элемент <span class="math inline">\(k\)</span>, размер нового множества</p>
<p>будет как минимум, в два раза больше старого, в котором он хранился.</p>
<p><em>Упражнение*:</em> дана строка <span class="math inline">\(s\)</span>. Найти число строк <span class="math inline">\(t\)</span> таких, что</p>
<p>они имеют хотя бы <span class="math inline">\(3\)</span> <em>непересекающихся</em> вхождения в строку <span class="math inline">\(s\)</span>.</p></li>
<li><p><strong>Наибольшая общая подстрока.</strong> Нам дано <span class="math inline">\(k\)</span> строк</p>
<p><span class="math inline">\(s_1, s_2, \dots, s_k\)</span>. Нужно найти наибольшую строку <span class="math inline">\(t\)</span>, которая</p>
<p>встречается в каждой из строк <span class="math inline">\(s_i\)</span>. Одно из возможных решений —</p>
<p>построить автомат для строки <span class="math inline">\(s_1 t_1 s_2 t_2 \dots s_n t_n\)</span>, где</p>
<p><span class="math inline">\(t_i\)</span> — уникальный для каждой строки символ-разделитель. Теперь мы</p>
<p>можем завести динамику <span class="math inline">\(dp[q][i]\)</span>, в которой хранить <span class="math inline">\(1\)</span>, если из</p>
<p>состояния <span class="math inline">\(q\)</span> можно добраться до состояния, из которого есть переход</p>
<p>по <span class="math inline">\(t_i\)</span>, не проходя при этом через другие символы-разделители. Это</p>
<p>будет равносильно тому, что строки из <span class="math inline">\(q\)</span> входят в <span class="math inline">\(s_i\)</span>. Как и в</p>
<p>прошлый раз, динамику можно пересчитывать по топологической</p>
<p>сортировке автомата как ориентированного ациклического графа. Итого</p>
<p>решение будет работать за <span class="math inline">\(O(k \cdot \sum |s_i|)\)</span>.</p>
<p><em>Упражнение*:</em> решить указанную задачу за <span class="math inline">\(O(\sum |s_i|)\)</span>.</p>
<h2 id="модификация-суффиксного-автомата">Модификация суффиксного автомата</h2>
<p>Эта модификация была придумана и рассказана Филиппом Грибовым, в частности, в рамках программы третьего курса кружка по алгоритмам Tinkoff Generation (2018-2019). Суть заключается в следующем: заметим, что при построении и доказательстве асимптотики на самом деле мы никак не использовали, что строится автомат только для одной строки. То есть после того, как мы построили суффиксный автомат по некоторой строке, мы можем сказать, что вершина, принимающая всю строку (last) - это корень автомата, и спокойно добавить в автомат вторую строку, и после этого автомат будет принимать все различные подстроки как первой, так и второй строк. Очевидно, можно так же построить автомат и для трёх, четырёх и т.д. строк, что даёт нам просто решать такие сложные задачи, как следующая:</p></li>
</ol>
<blockquote>
<p>Дан словарь строк, изначально пустой. Приходят запросы трёх типов: добавить строку в словарь, если её нет, удалить строку из словаря, если она есть, и найти суммарное количество вхождений строк словаря в заданный текст. Задача в онлайн.</p>
</blockquote>
<p>Сперва введём вспомогательное понятие. <em>Подавтоматом</em> состояния <span class="math inline">\(U\)</span> суффиксного автомата называется такой его подграф, что в нём есть пути по всем подстрокам самой длинной принимаемой <span class="math inline">\(U\)</span> строки и только по ним. Обойти подавтомат можно простой рекурсивной функцией типа DFS: по сути, для этого нам нужно пройтись по всем суффиксам всех префиксов (или наоборот) данной строки, то есть если мы находимся в состоянии <span class="math inline">\(X\)</span>, то мы либо ничего не делаем, если <span class="math inline">\(X\)</span> уже была посещена этим обходом, либо запускаем функцию сначала от вершины, достижимой по префиксной ссылке, а затем по суффиксной. Теперь можно перейти к решению задачи. Для обработки запроса первого типа просто добавим строку в суффиксный автомат и пометим последнюю вершину как терминальную, т.е. отвечающую за одну из строк. Для обработки запроса второго типа найдём вершину, отвечающую за данную строку, и если она есть, просто снимем терминальную пометку. Для обработки запроса третьего типа добавим заданную строку в суффиксный автомат и пройдёмся по её подавтомату, при этом запоминая для каждой вершины количество вершин с терминальной меткой в её подавтомате. Тогда если мы попали в уже посещённую во время обхода подавтомата вершину, то просто прибавим уже посчитанный для неё ответ. Осталось только понять асимптотику, ведь если в автомате есть несколько строк, то может случиться так, что у некоторых размер подавтомата будет порядка квадрата от их длины. Пусть суммарная длина всех строк запросов это <span class="math inline">\(m\)</span>. Давайте разделим строки на тяжёлые (длина больше <span class="math inline">\(\sqrt{m}\)</span>) и лёгкие (длина не больше <span class="math inline">\(\sqrt{m}\)</span>). тяжёлых строк не больше <span class="math inline">\(\sqrt{m}\)</span>, и при этом размер подавтомата любой строки не больше <span class="math inline">\(O(m)\)</span>, поэтому суммарное время обработки тяжёлых строк не больше $O(m ). Лёгких строк может быть много, и размер подавтомата строки длиной <span class="math inline">\(l\)</span> может быть <span class="math inline">\(O(l^2)\)</span>, что не больше, чем <span class="math inline">\(O(\sqrt{m})\)</span>; суммарная длина всех строк не больше <span class="math inline">\(m\)</span>, а значит суммарное время на обработку всех лёгких строк также порядка <span class="math inline">\(O(m \sqrt{m})\)</span>. Таким образом, мы получили довольно простое решение такой задачи за <span class="math inline">\(O(m \sqrt{m})\)</span> с небольшой константой, которое заходит даже для <span class="math inline">\(m\)</span> порядка <span class="math inline">\(10^6\)</span>. И таким образом можно строить не только суффиксный автомат по нескольким строкам: можно “подвешивать” одну строку к другой и т.д.</p>
<h3 id="реализация">Реализация</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">struct</span> node {</a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">int</span> link = -<span class="dv">1</span>, p = -<span class="dv">1</span>, len = <span class="dv">0</span>; <span class="co">// Суффиксная, префиксная ссылки и максимальная длина принимаемой состоянием строки, соответственно</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">char</span> pc = <span class="ch">&#39;#&#39;</span>; <span class="co">// Символы, переходы по которым ведут в состояние</span></a>
<a class="sourceLine" id="cb1-4" title="4">  map&lt;<span class="dt">char</span>, <span class="dt">int</span>&gt; next; <span class="co">// Переходы по символам</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6">  node() {}</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">  node(<span class="dt">int</span> p, <span class="dt">int</span> len, <span class="dt">char</span> pc) : p(p), len(len), pc(pc) {}</a>
<a class="sourceLine" id="cb1-9" title="9">};</a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">node v[<span class="dv">2</span> * MAXN]; <span class="co">// MAXN - максимально возможная суммарная длина строк</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="dt">int</span> mx = <span class="dv">0</span>; <span class="co">// номер последнего добавленного состояния</span></a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="dt">int</span> add_char(<span class="dt">int</span> ls, <span class="dt">char</span> c) { <span class="co">// ls - состояние, к которому мы &quot;подвешиваем&quot; следующий символ, c - сам символ</span></a>
<a class="sourceLine" id="cb1-15" title="15">  <span class="cf">if</span> (v[ls].next.find(c) != v[ls].end()) <span class="cf">return</span> v[ls].next[c]; <span class="co">// Если переход по символу c из ls уже был, то ничего добавлять не надо</span></a>
<a class="sourceLine" id="cb1-16" title="16">  v[++mx] = node(ls, v[ls].len + <span class="dv">1</span>, c);</a>
<a class="sourceLine" id="cb1-17" title="17">  <span class="dt">int</span> p = ls;</a>
<a class="sourceLine" id="cb1-18" title="18">  <span class="cf">for</span> (; p != -<span class="dv">1</span> &amp;&amp; v[p].next.find(c) == v[p].end(); p = v[p].link)</a>
<a class="sourceLine" id="cb1-19" title="19">      v[p].next[c] = mx;</a>
<a class="sourceLine" id="cb1-20" title="20">  <span class="cf">if</span> (p == -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb1-21" title="21">      v[mx].link = <span class="dv">0</span>; <span class="co">// Если перехода по c не нашлось</span></a>
<a class="sourceLine" id="cb1-22" title="22">      <span class="cf">return</span> mx;</a>
<a class="sourceLine" id="cb1-23" title="23">  }</a>
<a class="sourceLine" id="cb1-24" title="24">  <span class="dt">int</span> q = v[p].next[c];</a>
<a class="sourceLine" id="cb1-25" title="25">  <span class="cf">if</span> (v[q].p == p) {</a>
<a class="sourceLine" id="cb1-26" title="26">      v[mx].link = q;</a>
<a class="sourceLine" id="cb1-27" title="27">      <span class="cf">return</span> mx;</a>
<a class="sourceLine" id="cb1-28" title="28">  }</a>
<a class="sourceLine" id="cb1-29" title="29">  v[++mx] = node(p, v[p].len + <span class="dv">1</span>, c); <span class="co">// Клонирование</span></a>
<a class="sourceLine" id="cb1-30" title="30">  v[mx].next = v[q].next; v[mx].link = v[q].link;</a>
<a class="sourceLine" id="cb1-31" title="31">  v[q].link = v[mx - <span class="dv">1</span>].link = mx;</a>
<a class="sourceLine" id="cb1-32" title="32">  <span class="cf">for</span> (; p != -<span class="dv">1</span> &amp;&amp; v[p].next[c] == q; p = v[p].link)</a>
<a class="sourceLine" id="cb1-33" title="33">      v[p].next[c] = mx;</a>
<a class="sourceLine" id="cb1-34" title="34">  <span class="cf">return</span> mx - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb1-35" title="35">}</a>
<a class="sourceLine" id="cb1-36" title="36"></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="dt">int</span> used[MAXN * <span class="dv">2</span>]; <span class="co">// Массив времён посещения обходом подавтомата</span></a>
<a class="sourceLine" id="cb1-38" title="38"></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="dt">void</span> subautomaton(<span class="dt">int</span> x, <span class="dt">int</span> tm) { <span class="co">// Обход подавтомата</span></a>
<a class="sourceLine" id="cb1-40" title="40">  <span class="cf">if</span> (x == -<span class="dv">1</span> || used[x] == tm) <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb1-41" title="41"></a>
<a class="sourceLine" id="cb1-42" title="42">  used[x] = tm;</a>
<a class="sourceLine" id="cb1-43" title="43">  <span class="co">//....</span></a>
<a class="sourceLine" id="cb1-44" title="44"></a>
<a class="sourceLine" id="cb1-45" title="45">  subautomaton(v[x].p, tm);</a>
<a class="sourceLine" id="cb1-46" title="46">  subautomaton(v[x].link, tm);</a>
<a class="sourceLine" id="cb1-47" title="47">}</a></code></pre></div>
</body>
</html>
