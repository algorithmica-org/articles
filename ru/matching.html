<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Паросочетания - Алгоритмика</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />

  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->

  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/ru/'><div id='logo'>Алгоритмика</div></a>
    <div id='links'>
        <a href='https://github.com/algorithmica-org/ru/edit/master/matching.md'>Редактировать</a>
        <a href='https://github.com/algorithmica-org/ru/commits/master/matching.md'>История</a>
    </div>
</div>
<div class="migration"><a href='https://ru.algorithmica.org/cs/'>Сайт переезжает.</a> Большинство статей уже перенесено на новую версию.<br>Скоро добавим автоматические переходы, но пока обновленную версию этой статьи можно найти там.</div>
<h1 id="паросочетания">Паросочетания</h1>
<p><strong>Задача.</strong> Пусть есть <span class="math inline">\(n\)</span> мальчиков и <span class="math inline">\(m\)</span> девочек. Про каждого мальчика и про каждую девочку известно, с кем они не против танцевать. Нужно составить как можно больше пар, в которых партнёры хотят танцевать друг с другом.</p>
<p><img src="http://www.science4all.org/wp-content/uploads/2012/06/maximum_matching.png"  width="400px"></p>
<p>Формализуем эту задачу, представив мальчиков и девочек как вершины в двудольном графе, рёбрами которого будет отношение «могут танцевать вместе».</p>
<p><strong>Паросочетанием</strong> <span class="math inline">\(M\)</span> называется набор попарно несмежных рёбер графа (иными словами, любой вершине графа должно быть инцидентно не более одного ребра из <span class="math inline">\(M\)</span>).</p>
<p>Все вершины, у которых есть смежное ребро из паросочетания (т.е. которые имеют степень ровно один в подграфе, образованном <span class="math inline">\(M\)</span>), назовём <em>насыщенными</em> этим паросочетанием.</p>
<p><em>Мощностью</em> паросочетания назовём количество рёбер в нём. <em>Наибольшим</em> (<em>максимальным</em>) паросочетанием назовём паросочетание, мощность которого максимальна среди всех возможных паросочетаний в данном графе, а <em>совершенным</em> — где все вершины левой доли им насыщенны.</p>
<p>Паросочетания <a href="http://e-maxx.ru/algo/matching_edmonds">можно искать</a> в любых графах, однако этот алгоритм неприятно кодить, и он работает за <span class="math inline">\(O(n^3)\)</span>, так что сегодня мы сфокусируемся только на двудольных графах. Будем в дальнейшем обозначать левую долю графа как <span class="math inline">\(L\)</span>, а правую долю как <span class="math inline">\(R\)</span>.</p>
<p><strong>Цепью</strong> длины <span class="math inline">\(k\)</span> назовём некоторый простой путь (т.е. не содержащий повторяющихся вершин или рёбер), содержащий ровно <span class="math inline">\(k\)</span> рёбер.</p>
<p><strong>Чередующейся цепью</strong> относительно некоторого паросочетания назовём простой путь длины <span class="math inline">\(k\)</span> в которой рёбра поочередно принадлежат/не принадлежат паросочетанию.</p>
<p><strong>Увеличивающей цепью</strong> относительно некоторого паросочетания назовём чередующуюся цепь, у которой начальная и конечная вершины не принадлежат паросочетанию.</p>
<p><img src="https://neerc.ifmo.ru/wiki/images/4/4a/Alternating_path.jpg" /></p>
<p><em>Здесь красными помечены вершины паросочетания, а в графе есть увеличивающая цепь: <span class="math inline">\(1 \to 8 \to 4 \to 6 \to 3 \to 7\)</span>.</em></p>
<p>Зачем нужны увеличивающие цепи? Оказывается, можно с их помощью увеличивать паросочетание на единицу (отсюда и название). Можно взять такой путь и провести <strong>чередование</strong> — убрать из паросочетания все рёбра, принадлежащие цепи, и, наоборот, добавить все остальные. Всего в увеличивающей цепи нечетное число рёбер, а первое и последнее были не в паросочетании. Значит, мощность паросочетания увеличилась ровно на единицу.</p>
<p>В примере добавятся синие рёбра <span class="math inline">\((1, 8)\)</span>, <span class="math inline">\((3, 7)\)</span> и <span class="math inline">\((4, 6)\)</span>, а удалятся красные <span class="math inline">\((3, 6)\)</span> и <span class="math inline">\((4, 8)\)</span>. С ребром <span class="math inline">\((2, 5)\)</span> ничего не случится — оно не в увеличивающей цепи. Таким образом, размер паросочетания увеличится на единицу.</p>
<p><strong>Алгоритм Куна</strong> в этом и заключается — будем искать увеличивающую цепь, пока ищется, и проводить чередование в ней. Увеличивающие цепи удобны тем, что их легко искать: можно просто запустить поиск пути из произвольной свободной вершины из левой доли в какую-нибудь свободную вершину правой доли в том же графе, но в котором из правой доли можно идти только по рёбрам паросочетания (то есть у вершин правой доли будет либо одно ребро, либо ноль). Это можно делать как угодно (для упражнения автор рекомендует явно строить такой граф, искать путь и явно проводить чередования), однако устоялась эффективная реализация в виде dfs на 20 строчек кода, приведённая ниже.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> maxn<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> g<span class="op">[</span>maxn<span class="op">];</span> <span class="co">// будем хранить только рёбра из левой доли в правую</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mt<span class="op">[</span>maxn<span class="op">];</span> <span class="co">// с какой вершиной сматчена вершина правой доли (-1, если ни с какой)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> used<span class="op">[</span>maxn<span class="op">];</span> <span class="co">// вспомогательный массив для поиска пути dfs-ом</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">// dfs возвращает, можно ли найти путь из вершины v</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">// в какую-нибудь вершину правой доли</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">// если можно, то ещё и проводит чередование</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> dfs<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>used<span class="op">[</span>v<span class="op">])</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    used<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">:</span> g<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// если вершина свободна, то можно сразу с ней соединиться</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// если она занята, то с ней можно соединиться только тогда,</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// когда из её текущей пары можно найти какую-нибудь другую вершину</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mt<span class="op">[</span>u<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">||</span> dfs<span class="op">(</span>mt<span class="op">[</span>u<span class="op">]))</span> <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            mt<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co">// где-то в main:</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>memset<span class="op">(</span>mt<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="kw">sizeof</span> mt<span class="op">);</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>used<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span> mt<span class="op">);</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>dfs<span class="op">(</span>i<span class="op">))</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        cnt<span class="op">++;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="корректность">Корректность</h2>
<p>Для доказательства алгоритма нам будет достаточно ещё доказать, что если увеличивающие цепи уже не ищутся, то паросочетание в принципе нельзя увеличить.</p>
<p><strong>Теорема (Бержа)</strong>. Паросочетание без увеличивающих цепей является максимальным.</p>
<p><strong>Доказательство</strong> проведём от противного: пусть есть два паросочетания вершин <span class="math inline">\(|A| \leq |B|\)</span>, и для <span class="math inline">\(A\)</span> нет увеличивающих путей, и покажем, как найти этот путь и увеличить <span class="math inline">\(A\)</span> на единицу.</p>
<p>Раскрасим ребра из паросочетания, соответствующего <span class="math inline">\(A\)</span> в красный цвет, <span class="math inline">\(B\)</span> — в синий, а ребра из обоих паросочетаний — в пурпурный. Рассмотрим граф из только красных и синих ребер. Любая компонента связности в нём представляет собой либо путь, либо цикл, состоящий из чередующихся красных и синих ребер. В любом цикле будет равное число красных и синих рёбер, а так как всего синих рёбер больше, то должен существовать путь, начинающийся и оканчивающийся синим ребром — он и будет увеличивающей цепью для <span class="math inline">\(A\)</span>, а значит <span class="math inline">\(A\)</span> не оптимальное, и мы получили противоречие.</p>
<h2 id="скорость-работы">Скорость работы</h2>
<p>Такой алгоритм ровно <span class="math inline">\(n\)</span> раз ищет увеличивающий путь, каждый раз просматривая не более <span class="math inline">\(m\)</span> рёбер, а значит работает за <span class="math inline">\(O(nm)\)</span>.</p>
<p>Что примечательно, его можно не бояться запускать на ограничениях и побольше (<span class="math inline">\(n, m \approx 10^4\)</span>), потому что для него есть мощные неасимптотические оптимизации:</p>
<ul>
<li><p>Eго можно жадно инициализировать (просто заранее пройтись по вершинам левой доли и сматчить их со свободной вершиной правой, если она есть).</p></li>
<li><p>Можно не заполнять нулями на каждой итерации массив <code>used</code>, а использовать следующий трюк: хранить в нём вместо булева флага версию последнего изменения, а конкретно – номер итерации, на которой это значение стало <code>true</code>. Если этот номер меньше текущего номера итерации, то мы можем воспринимать это значение как <code>false</code>. В каком-то смысле это позволяет эмулировать очищение массива за константу.</p></li>
<li><p>Очень часто граф приходит из какой-то другой задачи, природа которой накладывает ограничения на его вид. Например, в задачах на решетках (когда есть двумерный массив, и соседние клетки связаны друг с другом) граф двудольный, но степень каждой вершины маленькая, и граф имеет очень специфичную структуру, и на нём алгоритм Куна работает быстрее, чем ожидается из формулы <span class="math inline">\(n \times m\)</span>. Контрпримеры в таких задачах на самом деле почти всегда можно сгенерировать, но авторы редко так заморачиваются.</p></li>
</ul>
<p>Вообще говоря, увлекаться ускорением алгоритма Куна не стоит — существует более асимптотически быстрый алгоритм. Задача нахождения максимального паросочетания — частный случай задачи о максимальном потоке, и если применить <a href="http://e-maxx.ru/algo/dinic">алгоритм Диница</a> к двудольным графам с единичной пропускной способностью, то выясняется, что работать он будет за <span class="math inline">\(O(m \sqrt n)\)</span>.</p>
<h2 id="покрытие-путями-dag-а">Покрытие путями DAG-а</h2>
<p>Сводить задачи к поиску максимального паросочетания обычно не очень трудно, но в некоторых случаях самому додуматься сложно. Разберём одну такую известную задачу. Дан ориентированный ациклический граф <span class="math inline">\(G\)</span> (англ. <em>directed acyclic graph</em>). Требуется покрыть его наименьшим числом путей, то есть найти наименьшее множество простых путей, где каждая вершина принадлежит ровно одному пути.</p>
<p>Построим соответствующие изначальному графу <span class="math inline">\(G\)</span> два двудольных графа <span class="math inline">\(H\)</span> и <span class="math inline">\(\overline{H}\)</span> следующим образом:</p>
<ul>
<li>В каждой доле графа <span class="math inline">\(H\)</span> будет по <span class="math inline">\(n\)</span> вершин. Обозначим их через <span class="math inline">\(a_i\)</span> и <span class="math inline">\(b_i\)</span> соответственно.</li>
<li>Для каждого ребра <span class="math inline">\((i, j)\)</span> исходного графа <span class="math inline">\(G\)</span> проведём соответствующее ребро <span class="math inline">\((a_i, b_j)\)</span> в графе <span class="math inline">\(H\)</span>.</li>
<li>Теперь из графа <span class="math inline">\(H\)</span> сделаем граф <span class="math inline">\(\overline{H}\)</span>, добавив обратное ребро <span class="math inline">\((b_i, a_i)\)</span> для каждого <span class="math inline">\(i\)</span>.</li>
</ul>
<p>Если мы рассмотрим любой путь <span class="math inline">\(v_1, v_2, \ldots, v_k\)</span> в исходном графе <span class="math inline">\(G\)</span>, то в графе <span class="math inline">\(\overline{H}\)</span> ему будет соответствовать путь <span class="math inline">\(a_{v_1}, b_{v_2}, a_{v_2}, b_{v_3}, \ldots, a_{v_{k-1}}, b_{v_k}\)</span>. Обратное тоже верно: любой путь, начинающийся в левой доле <span class="math inline">\(\overline{H}\)</span> и заканчивающийся в правой будет соответствовать какому-то пути в <span class="math inline">\(G\)</span>.</p>
<p>Итак, есть взаимно однозначное соответствие между путями в <span class="math inline">\(G\)</span> и путями <span class="math inline">\(\overline{H}\)</span>, идущими из левой доли в правую. Заметим, что любой такой путь в <span class="math inline">\(\overline{H}\)</span> — это паросочетание в <span class="math inline">\(H\)</span> (напомним, это <span class="math inline">\(\overline{H}\)</span> без обратных рёбер). Получается, любому пути из <span class="math inline">\(G\)</span> можно поставить в соответствие паросочетание в <span class="math inline">\(H\)</span>, и наоборот. Более того, непересекающимся путям в <span class="math inline">\(G\)</span> соответствуют непересекающиеся паросочетания в <span class="math inline">\(H\)</span>.</p>
<p>Заметим, что если есть <span class="math inline">\(p\)</span> непересекающихся путей, покрывающих все <span class="math inline">\(n\)</span> вершин графа, то они вместе содержат <span class="math inline">\(r = n - p\)</span> рёбер. Отсюда получаем, что чтобы минимизировать число путей <span class="math inline">\(p\)</span>, мы должны максимизировать число рёбер <span class="math inline">\(r\)</span> в них.</p>
<p>Мы теперь можем свести задачу к нахождению максимального паросочетания в двудольном графе <span class="math inline">\(H\)</span>. После нахождения этого паросочетания мы должны преобразовать его в набор путей в <span class="math inline">\(G\)</span>. Это делается тривиальным алгоритмом: возьмем <span class="math inline">\(a_1\)</span>, посмотрим, с какой <span class="math inline">\(b_k\)</span> она соединена, посмотрим на <span class="math inline">\(a_k\)</span> и так далее. Некоторые вершины могут остаться ненасыщенными — в таком случае в ответ надо добавить пути нулевой длины из каждой из этих вершин.</p>
<h2 id="лемма-холла">Лемма Холла</h2>
<p><em>Лемма Холла</em> (или: <em>теорема о свадьбах</em>) — очень удобный критерий в задачах, где нужно проверить, что паросочетание существует, но при этом не требуется строить его явно.</p>
<p><img src="https://neerc.ifmo.ru/wiki/images/2/2f/Aba.gif" /></p>
<p><strong>Лемма Холла</strong>. Полное паросочетание существует тогда и только тогда, когда любая группа вершин левой доли соединена с не меньшим количеством вершин правой доли.</p>
<p><strong>Доказательство</strong>. В одну сторону понятно — если совершенное паросочетание есть, то для любого подмножества вершин левой доли можно взять вершины правой, соединенные с ним паросочетанием.</p>
<p>В другую сложнее — нужно воспользоваться индукцией. Будем доказывать, что если паросочетание не полное, то можно в таком графе найти увеличивающую цепь, и с её помощью увеличить паросочетание на единицу.</p>
<p><strong>База индукции</strong>: одна вершина из <span class="math inline">\(L\)</span>, которая по условию соединена с хотя бы одной вершиной из <span class="math inline">\(R\)</span>.</p>
<p><strong>Индукционный переход</strong>: пусть после <span class="math inline">\(k &lt; n\)</span> шагов построено паросочетание <span class="math inline">\(M\)</span>. Докажем, что в <span class="math inline">\(M\)</span> можно добавить вершину <span class="math inline">\(v\)</span> из <span class="math inline">\(L\)</span>, не насыщенную паросочетанием.</p>
<p>Рассмотрим множество вершин <span class="math inline">\(H\)</span> — все вершины, достижимые из <span class="math inline">\(x\)</span>, если можно ходить из правой доли в левую только по рёбрам паросочетания, а из левой в правую — по любым (мы такой граф по сути строим, когда ищем увеличивающую цепь в алгоритме Куна)</p>
<p>Тогда в <span class="math inline">\(H\)</span> найдется вершина <span class="math inline">\(y\)</span> из <span class="math inline">\(R\)</span>, не насыщенная паросочетанием. Иначе, если такой вершины нет, то получается, что если рассмотреть вершины <span class="math inline">\(H_L\)</span> (вершины левой доли, насыщенные паросочетанием), то для них не будет выполнено условие, что <span class="math inline">\(|H_L| \leq |N(H_L)|\)</span> (здесь <span class="math inline">\(N(X)\)</span> — множество вершин, соединенным паросочетанием с <span class="math inline">\(X\)</span>).</p>
<p>Тогда должен существовать путь из <span class="math inline">\(x\)</span> в <span class="math inline">\(y\)</span>, и он будет увеличивающим для паросочетания <span class="math inline">\(M\)</span>, потому что из <span class="math inline">\(R\)</span> в <span class="math inline">\(L\)</span> мы всегда шли только по ребрам паросочетания. Проведя чередование вдоль этого пути, получим большее паросочетание, следовательно предположение индукции верно.</p>
<h2 id="минимальное-вершинное-покрытие">Минимальное вершинное покрытие</h2>
<p><strong>Задача</strong>. Дан граф. Назовем <em>вершинным покрытием</em> такое множество вершин, что каждое ребро графа инцидентно хотя бы одной вершине из множества. Необходимо найти вершинное покрытие наименьшего размера.</p>
<p>Следует заметить, что в общем случае это очень сложная задача, но для двудольных графов она имеет достаточно простое решение.</p>
<p><strong>Теорема</strong>. <span class="math inline">\(\mid V_{min} \mid \le \mid M \mid\)</span>, где <span class="math inline">\(V_{min}\)</span> — минимальное вершинное покрытие, а <span class="math inline">\(M\)</span> — максимальное паросочетание.</p>
<p><strong>Доказательство</strong>. <span class="math inline">\(\mid V_{min} \mid \ge \mid M \mid\)</span>, поскольку <span class="math inline">\(M\)</span> — множество независимых ребер. Теперь приведем алгоритм, который строит вершинное покрытие размера <span class="math inline">\(\mid M \mid\)</span>. Очевидно, оно будет минимальным.</p>
<p><strong>Алгоритм</strong>. Мысленно ориентируем ребра графа: ребра из <span class="math inline">\(M\)</span> проведем из правой доли в левую, остальные — из левой в правую, после чего запустим обход в глубину из всех вершин левой доли, не включенных в <span class="math inline">\(M\)</span>.</p>
<p><img src="https://neerc.ifmo.ru/wiki/images/4/4c/Bipartdfs_right.jpg" /></p>
<p>Заметим, что граф разбился на несколько множеств: <span class="math inline">\(L^+, L^-, R^+, R^-\)</span>, где “плюсовые” множества — это множества посещенных в процессе обхода вершин. В графе такого вида не бывает ребер <span class="math inline">\(L^+ \rightarrow R^-\)</span>, <span class="math inline">\(L^- \leftarrow R^+\)</span> по очевидным соображениям. Ребер <span class="math inline">\(L^+ \leftarrow R^-\)</span> не бывает, потому что в противном случае паросочетание <span class="math inline">\(M\)</span> не максимальное — его можно дополнить ребрами такого типа.</p>
<p><span class="math display">\[
L^- \cup R^+ = V_{min}
\]</span></p>
<p>Понятно, что данное множество покроет все ребра. Осталось выяснить, почему <span class="math inline">\(L^- \cup R^+\)</span>. Это верно потому, что <span class="math inline">\(L^- \cup R^+\)</span> покрывает все ребра <span class="math inline">\(M\)</span> ровно один раз (ведь ребра <span class="math inline">\(L^- \rightarrow R^+\)</span> не принадлежат <span class="math inline">\(M\)</span>), а также потому, что в нем нет вершин, не принадлежащих <span class="math inline">\(M\)</span> (для <span class="math inline">\(L^-\)</span> это справедливо по определению, для <span class="math inline">\(R^+\)</span> можно провести доказательство от противного с использованием чередующихся цепей).</p>
<p><strong>Упражнение</strong>. Подумайте, как это можно применить к решению задачи о нахождении <a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%B2%D1%8F%D0%B7%D1%8C_%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D1%8F_%D0%B8_%D0%BD%D0%B5%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D0%B3%D0%BE_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0">максимального независимого множества</a>.</p>
<h2 id="для-ноулайферов-матроиды">Для ноулайферов: матроиды</h2>
<p>С весьма большой вероятностью матроиды вам никогда не пригодятся в школьных олимпиадах, однако, если вам совсем нечего делать, можете про них <a href="matroid">почитать</a>.</p>
<p>Математика вообще занимается тем, что обобщает всякие объекты и старается формулировать все теоремы максимально абстрактно. Так, концепцию <em>хороших подмножеств</em> (паросочетаний) обобщает понятие <strong>матроида</strong>. Практическое применение — жадный алгоритм Радо-Эдмондса, который нужен для обоснования большого числа жадников, где нужно набрать какое-то подмножество минимального / максимального веса. Сам алгоритм максимально простой: давайте отсортируем эти объекты по весу и будем добавлять их в таком порядке в наше <em>хорошее</em> множество, если оно после добавления остается <em>хорошим</em>.</p>
<p><strong>Применимо к паросочетаниям</strong>: пусть у вершин левой доли есть вес, и нам нужно набрать максимальное паросочетание минимального веса. Тогда выясняется, что можно просто отсортировать вершины левой доли по весу и пытаться в таком порядке добавлять их в паросочетание стандартным алгоритмом Куна.</p>
</body>
</html>
