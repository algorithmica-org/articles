<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Декартово дерево - Алгоритмика</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfjBggQFxAS4ilBAAACgElEQVRIx52VS0iUYRSGn/8fzbxMIYoRKSZKi2wGwo2FxRQZIlGbaGUF0b52LWbTLlx0W7VyEZiBWkE5mraRRrJFRUwolQw6zQTeuoiU423eFuk0M//nhJ7dd+Z7n/8932HOscgIgU0lR/Cxn3LKgGlijDJIkAgJiywhZMujVo0qrsyIa1St8shWFnmp/IooW0TkV6mMYuRVQCv6X6woIK+QQ16vkPP2M/WZICHVpyGEvCb5vE7olH6bEV6l1R4w3RpQkYoVNJcSWHsLIUt+rTpvLOuSELqihAmwKr8sgZBHE2aX5UKoRmNmDxPyCBtoodLU1m5yaADC9Jr7XkkLoCqNmPAx1eqqnqhAqEHfzB5GVGXTQLUJ/5xZznGcOuAtQbOHahpsfOQ5f5mng8McZAdnsVigkyUTIA8fGjZ561OpuiRJY6oR2qU35iKGbSqc4GU6qObYmstmYIrH5iIq0JIT+17lupU8BVUsVKsvJgdLtgnbxXZOJ091HAU+0W+0YCnGnvRUlCa+42OdbRHiA3CSbtyZ+q85RDMBfcxxjZKUf5uPO4wwzGsaMwFR1JZe1Jx8uuB4mBtC6LJzXLTZDLKYihziM+fJzfjQGfYC/XxMTy8yaDNEOLWBDznAIcdT7aMRiPI0PR1myGacnn+Zd7ygiUIHwEUjuUAnsdR0D+M20E7k7/knt5ki39guN9uAEPeIr6citIPrOsxQiC9hveIuLylkkgXyKUsR/2CAB8yyEzdhJiliN3aCmzwCCwSl3FfzDL9wYZFAuClJAcSZJoELALFKAWVYvVxkdm3NbDRUs0TqUM021jeU15s2w9YXSxKy9dWWRGx6uVpOyObW+x/B+LEV0hF3cAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wNi0wOFQxNjoyMzoxNiswMjowMLEfSBUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDYtMDhUMTY6MjM6MTYrMDI6MDDAQvCpAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC" rel="icon" type="image/x-icon" />

  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
     (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
     m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
     (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

     ym(53961409, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
     });
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->

  <script>
  // index page width
  document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementsByClassName('contents')[0].parentElement.style.width = "860px";
    document.getElementsByTagName('h1')[0].style.marginRight = "40px";
  });
  </script>
</head>
<body>
<div id='header'>
    <a href='https://algorithmica.org/ru/'><div id='logo'>Алгоритмика</div></a>
    <div id='links'>
        <a href='https://github.com/algorithmica-org/ru/edit/master/treap.md'>Редактировать</a>
        <a href='https://github.com/algorithmica-org/ru/commits/master/treap.md'>История</a>
    </div>
</div>
<div class="migration"><a href='https://ru.algorithmica.org/cs/'>Сайт переезжает.</a> Большинство статей уже перенесено на новую версию.<br>Скоро добавим автоматические переходы, но пока обновленную версию этой статьи можно найти там.</div>
<h1 id="декартово-дерево">Декартово дерево</h1>
<p>Рене Декарт (фр. <em>René Descartes</em>) — великий французский математик и философ XVII века.</p>
<p>Рене Декарт не является создателем декартова дерева, но он является создателем декартовой системы координат, которую мы все знаем и любим.</p>
<p>Декартово дерево же определяется и строится так:</p>
<ul>
<li>Нанесём на плоскость набор из <span class="math inline">\(n\)</span> точек. Их <span class="math inline">\(x\)</span> зачем-то назовем <em>ключом</em>, а <span class="math inline">\(y\)</span> <em>приоритетом</em>.</li>
<li>Выберем самую верхнюю точку (с наибольшим <span class="math inline">\(y\)</span>, а если таких несколько — любую) и назовём её <em>корнем</em>.</li>
<li>От всех вершин, лежащих слева (с меньшим <span class="math inline">\(x\)</span>) от корня, рекурсивно запустим этот же процесс. Если слева была хоть одна вершина, то присоединим корень левой части в качестве левого сына текущего корня.</li>
<li>Аналогично, запустимся от правой части и добавим корню правого сына.</li>
</ul>
<p>Заметим, что если все <span class="math inline">\(y\)</span> и <span class="math inline">\(x\)</span> различны, то дерево строится однозначно.</p>
<p>Если нарисовать получившуюся структуру на плоскости, то получится действительно дерево — по традиции, корнем вверх:</p>
<p><img src="https://hsto.org/storage/habraeffect/a1/0a/a10a744def8f325a1019502ecc175ef6.png" /></p>
<p>Таким образом, декартово дерево — это одновременно <em>бинарное дерево</em> по <span class="math inline">\(x\)</span> и <em>куча</em> по <span class="math inline">\(y\)</span>. Поэтому ему придумали много альтернативных названий:</p>
<ul>
<li><p>Дерамида (дерево + пирамида)</p></li>
<li><p>ПиВо (пирамида + дерево)</p></li>
<li><p>КуРево (куча + дерево)</p></li>
<li><p>Treap (tree + heap)</p></li>
</ul>
<h2 id="бинарные-деревья">Бинарные деревья</h2>
<p>С небольшими модификациями, декартово дерево умеет всё то же, что и любое <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0">бинарное дерево поиска</a>, например:</p>
<ul>
<li><p>Добавить число <span class="math inline">\(x\)</span> в множество.</p></li>
<li><p>Определить, есть ли в множестве число <span class="math inline">\(x\)</span>.</p></li>
<li><p>Найти первое число, не меньшее <span class="math inline">\(x\)</span> (<code>lower_bound</code>).</p></li>
<li><p>Найти количество чисел в промежутке <span class="math inline">\([l, r]\)</span>.</p></li>
</ul>
<p>При этом все операции — за <span class="math inline">\(O(\log n)\)</span>.</p>
<p>На самом деле, бинарных деревьев очень много. В большинстве из них время выполнения операций пропорционально высоте дерева, поэтому в них придумываются разные инварианты, позволяющие эту высоту минимизировать до <span class="math inline">\(O(\log n)\)</span>.</p>
<h2 id="приоритеты-и-асимптотика">Приоритеты и асимптотика</h2>
<p>В декартовом дереве логарифмическая высота дерева гарантируется не инвариантами и эвристиками, а законами теории вероятностей: оказывается, что если все приоритеты (<span class="math inline">\(y\)</span>) выбирать случайно, то средняя глубина вершины будет логарифмической. Поэтому ДД ещё называют рандомизированным деревом поиска.</p>
<p><strong>Теорема</strong>. Ожидание глубины вершины в декартовом дереве равно <span class="math inline">\(O(\log n)\)</span>.</p>
<p><strong>Доказательство.</strong> Введем функцию <span class="math inline">\(a(x, y)\)</span> равную единице, если <span class="math inline">\(x\)</span> является предком <span class="math inline">\(y\)</span>, и нулем в противном случае. Такие функции называются <em>индикаторами</em>.</p>
<p>Глубина вершины равна количеству её предков — прим. К. О. Таким образом, она равна</p>
<p><span class="math display">\[
d_i = \sum_{j=1}^n a(j, i)
\]</span></p>
<p>Её матожидание равно</p>
<p><span class="math display">\[
E[d_i] = E[\sum_{j \neq i} a(j, i)] = \sum_{j \neq i} E[a(j, i)] = \sum_{j \neq i} E[a(j, i)] = \sum_{j \neq i} p(j, i)
\]</span></p>
<p>где <span class="math inline">\(p(x, y)\)</span> это вероятность, что <span class="math inline">\(a(x, y) = 1\)</span>. Здесь мы воспользовались важным свойством <a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BE%D0%B6%D0%B8%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D0%BE%D0%B9_%D0%B2%D0%B5%D0%BB%D0%B8%D1%87%D0%B8%D0%BD%D1%8B#.D0.9B.D0.B8.D0.BD.D0.B5.D0.B9.D0.BD.D0.BE.D1.81.D1.82.D1.8C_.D0.BC.D0.B0.D1.82.D0.B5.D0.BC.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BE.D0.B6.D0.B8.D0.B4.D0.B0.D0.BD.D0.B8.D1.8F">линейности</a>: матожидание суммы чего угодно равна сумме матожиданий этого чего угодно.</p>
<p>Теперь осталось посчитать эти вероятности и сложить. Но сначала нам понадобится вспомогательное утверждение.</p>
<p><strong>Лемма</strong>. Вершина <span class="math inline">\(x\)</span> является предком <span class="math inline">\(y\)</span>, если у неё приоритет больше, чем у всех вершин из полуинтервала <span class="math inline">\((x, y]\)</span> (без ограничения общности, будем считать, что <span class="math inline">\(x &lt; y\)</span>).</p>
<p><strong>Необходимость</strong>. Если это не так, то где-то между <span class="math inline">\(x\)</span> и <span class="math inline">\(y\)</span> есть вершина с большим приоритетом, чем <span class="math inline">\(x\)</span>. Она не может быть потомком <span class="math inline">\(x\)</span>, а значит <span class="math inline">\(x\)</span> и <span class="math inline">\(y\)</span> будут разделены.</p>
<p><strong>Достаточность</strong>. Если справа будет какая-то вершина с большим приоритетом, то её левым сыном будет какая-то вершина, которая будет являться предком <span class="math inline">\(x\)</span>. Таким образом, всё, что справа от <span class="math inline">\(y\)</span>, ни на что влиять не будет.</p>
<p>У всех вершин на любом отрезке одинаковая вероятность иметь наибольший приоритет. Объединяя этот факт с результатом леммы, мы можем получить выражение для искомых вероятностей:</p>
<p><span class="math display">\[
p(x, y) = \frac{1}{y-x+1}
\]</span></p>
<p>Теперь, чтобы найти матожидание, эти вероятности надо просуммировать:</p>
<p><span class="math display">\[
E[d_i] = \sum_{j \neq i} p(j, i) = \sum_{j \neq i} \frac{1}{|i-j|+1} \leq \sum_{i=1}^n \frac{1}{n} = O(\log n)
\]</span></p>
<p>Перед последним переходом мы получили сумму гармонического ряда.</p>
<p>Примечательно, что ожидаемая глубина вершин зависит от их позиции: вершина из середины должна быть примерно в два раза глубже, чем крайняя.</p>
<p><strong>Упражнение.</strong> Выведите из этого доказательства асимптотику <code>quicksort</code>.</p>
<h2 id="реализация">Реализация</h2>
<p>Декартово дерево удобно писать на указателях и структурах.</p>
<p>Создадим структуру <code>Node</code>, в которой будем хранить ключ и приоритет, а также указатели на левого и правого сына. Указателя на корень дерева достаточно для идентификации всего дерева. Поэтому, когда мы будем говорить «функция принимает два дерева» на самом деле будут иметься в виду указатели на их корни. К нулевому указателю же мы будем относиться, как к «пустому» дереву.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> key<span class="op">,</span> prior<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>l <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> <span class="op">*</span>r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">(</span><span class="dt">int</span> _key<span class="op">)</span> <span class="op">{</span> key <span class="op">=</span> _key<span class="op">,</span> prior <span class="op">=</span> rand<span class="op">();</span> <span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Объявим две вспомогательные функции, изменяющие структуру деревьев: одна будет разделять деревья, а другая объединять. Как мы увидим, через них можно легко выразить почти все функции, которые нам потом понадобятся.</p>
<h3 id="merge">Merge</h3>
<p>Принимает два дерева (два корня, <span class="math inline">\(L\)</span> и <span class="math inline">\(R\)</span>), про которые известно, что в левом все вершины имеют меньший ключ, чем все в правом. Их нужно объединить в одно дерево так, чтобы ничего не сломалось: по ключам это всё ещё дерево, а по приоритетами — куча.</p>
<p>Сначала выберем, какая вершина будет корнем. Здесь всего два кандидата — левый корень <span class="math inline">\(L\)</span> или правый <span class="math inline">\(R\)</span> — просто возьмем тот, у кого приоритет больше.</p>
<p>Пусть, для однозначности, это был левый корень. Тогда левый сын корня итогового дерева должен быть левым сыном <span class="math inline">\(L\)</span>. С правым сыном сложнее: возможно, его нужно смерджить с <span class="math inline">\(R\)</span>. Поэтому рекурсивно сделаем <code>merge(l-&gt;r, r)</code> и запишем результат в качестве правого сына.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Node<span class="op">*</span> merge <span class="op">(</span>Node <span class="op">*</span>l<span class="op">,</span> Node <span class="op">*</span>r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>l<span class="op">)</span> <span class="cf">return</span> r<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>r<span class="op">)</span> <span class="cf">return</span> l<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>l<span class="op">-&gt;</span>prior <span class="op">&gt;</span> r<span class="op">-&gt;</span>prior<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        l<span class="op">-&gt;</span>r <span class="op">=</span> merge<span class="op">(</span>l<span class="op">-&gt;</span>r<span class="op">,</span> r<span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> l<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        r<span class="op">-&gt;</span>l <span class="op">=</span> merge<span class="op">(</span>l<span class="op">,</span> r<span class="op">-&gt;</span>l<span class="op">);</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> r<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="split">Split</h3>
<p>Принимает дерево и ключ <span class="math inline">\(x\)</span>, по которому его нужно разделить на два: <span class="math inline">\(L\)</span> должно иметь все ключи не больше <span class="math inline">\(x\)</span>, а <span class="math inline">\(R\)</span> должно иметь все ключи больше <span class="math inline">\(x\)</span>.</p>
<p>В этой функции мы сначала решим, в каком из деревьев должен быть корень, а потом рекурсивно разделим его правую или левую половину и присоединим, куда надо:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> pair<span class="op">&lt;</span>Node<span class="op">*,</span> Node<span class="op">*&gt;</span> Pair<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>Pair split <span class="op">(</span>Node <span class="op">*</span>p<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>p<span class="op">)</span> <span class="cf">return</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>p<span class="op">-&gt;</span>key <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        Pair q <span class="op">=</span> split<span class="op">(</span>p<span class="op">-&gt;</span>r<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        p<span class="op">-&gt;</span>r <span class="op">=</span> q<span class="op">.</span>first<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>p<span class="op">,</span> q<span class="op">.</span>second<span class="op">};</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        Pair q <span class="op">=</span> split<span class="op">(</span>p<span class="op">-&gt;</span>l<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        p<span class="op">-&gt;</span>l <span class="op">=</span> q<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>q<span class="op">.</span>first<span class="op">,</span> p<span class="op">};</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="пример-вставка">Пример: вставка</h3>
<p><code>merge</code> и <code>split</code> сами по себе не очень полезные, но помогут написать все остальное.</p>
<p>Вот так, например, будет выглядеть код, добавляющий <span class="math inline">\(x\)</span> в дерево.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>Node <span class="op">*</span>root <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> insert <span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    Pair q <span class="op">=</span> split<span class="op">(</span>root<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>t <span class="op">=</span> <span class="kw">new</span> Node<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> merge<span class="op">(</span>q<span class="op">.</span>first<span class="op">,</span> merge<span class="op">(</span>t<span class="op">,</span> q<span class="op">.</span>second<span class="op">));</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="пример-модификация-для-суммы-на-отрезке">Пример: модификация для суммы на отрезке</h3>
<p>Иногда нам нужно написать какие-то модификации для более продвинутых операций.</p>
<p>Например, нам может быть интересно иногда считать сумму чисел на отрезке. Для этого в вершине нужно хранить также своё число и сумму на своем «отрезке».</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">,</span> sum<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>При <code>merge</code> и <code>split</code> надо будет поддерживать эту сумму актуальной.</p>
<p>Вместо того, чтобы модифицировать и <code>merge</code>, и <code>split</code> под наши хотелки, напишем вспомогательные функцию <code>upd</code>, которую будем вызывать при обновлении детей вершины.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sum <span class="op">(</span>Node<span class="op">*</span> v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> v <span class="op">?</span> v<span class="op">-&gt;</span>sum <span class="op">:</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">// обращаться по пустому указателю нельзя -- выдаст ошибку</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> upd <span class="op">(</span>Node<span class="op">*</span> v<span class="op">)</span> <span class="op">{</span> v<span class="op">-&gt;</span>sum <span class="op">=</span> sum<span class="op">(</span>v<span class="op">-&gt;</span>l<span class="op">)</span> <span class="op">+</span> sum<span class="op">(</span>v<span class="op">-&gt;</span>r<span class="op">)</span> <span class="op">+</span> v<span class="op">-&gt;</span>val<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>В <code>merge</code> и <code>split</code> теперь можно просто вызывать <code>upd</code> перед тем, как вернуть вершину, и тогда ничего не сломается:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>Node<span class="op">*</span> merge <span class="op">(</span>Node <span class="op">*</span>l<span class="op">,</span> Node <span class="op">*</span>r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        l<span class="op">-&gt;</span>r <span class="op">=</span> merge<span class="op">(</span>l<span class="op">-&gt;</span>r<span class="op">,</span> r<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        upd<span class="op">(</span>l<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> l<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> pair<span class="op">&lt;</span>Node<span class="op">*,</span> Node<span class="op">*&gt;</span> Pair<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>Pair split <span class="op">(</span>Node <span class="op">*</span>p<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        upd<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>p<span class="op">,</span> q<span class="op">.</span>second<span class="op">};</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Тогда при запросе суммы нужно просто вырезать нужный отрезок и запросить эту сумму:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum <span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    Pair rq <span class="op">=</span> split<span class="op">(</span>root<span class="op">,</span> r<span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    Pair lq <span class="op">=</span> split<span class="op">(</span>rq<span class="op">.</span>first<span class="op">,</span> l<span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> res <span class="op">=</span> sum<span class="op">(</span>lq<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> merge<span class="op">(</span>lq<span class="op">.</span>first<span class="op">,</span> merge<span class="op">(</span>lq<span class="op">.</span>second<span class="op">,</span> rq<span class="op">.</span>second<span class="op">));</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="неявный-ключ">Неявный ключ</h2>
<p>Обычное декартово дерево — это структура для множеств, каждый элемент которых имеет какой-то ключ. Эти ключи задают на этом множестве какой-то порядок, и все запросы к ДД обычно как-то привязаны к этому порядку.</p>
<p>Но что, если у нас есть запросы, которые этот порядок как-то нетривиально меняют? Например, если у нас есть массив, в котором нужно уметь выводить сумму на произвольном отрезке и «переворачивать» произвольный отрезок. Если бы не было второй операции, мы бы просто использовали индекс элемента в качестве ключа, но с операцией переворота нет способа их быстро поддерживать актуальными.</p>
<p>Решение такое: выкинем ключи, а вместо них будем поддерживать информацию, которая поможет неявно восстановить ключ, когда он нам будет нужен. А именно, будем хранить вместе с каждой вершиной размер её поддерева:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> key<span class="op">,</span> prior<span class="op">,</span> size <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//              ^ размер поддерева</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">*</span>l <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> <span class="op">*</span>r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    Node <span class="op">(</span><span class="dt">int</span> _key<span class="op">)</span> <span class="op">{</span> key <span class="op">=</span> _key<span class="op">,</span> prior <span class="op">=</span> rand<span class="op">();</span> <span class="op">}</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Размеры поддеревьев будем поддерживать по аналогии с суммой — напишем вспомогательную функцию, которую будем вызывать после каждого структурного изменения вершины.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size <span class="op">(</span>Node <span class="op">*</span>v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> v <span class="op">?</span> v<span class="op">-&gt;</span>size <span class="op">:</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> upd <span class="op">(</span>Node <span class="op">*</span>v<span class="op">)</span> <span class="op">{</span> v<span class="op">-&gt;</span>size <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> size<span class="op">(</span>v<span class="op">-&gt;</span>l<span class="op">)</span> <span class="op">+</span> size<span class="op">(</span>v<span class="op">-&gt;</span>r<span class="op">);</span> <span class="op">}</span></span></code></pre></div>
<p><code>merge</code> не меняется, а вот в <code>split</code> нужно использовать позицию корня вместо его ключа.</p>
<p>Про <code>split</code> теперь удобнее думать как “вырежи первые <code>k</code> элементов”.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> pair<span class="op">&lt;</span>Node<span class="op">*,</span> Node<span class="op">*&gt;</span> Pair<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>Pair split <span class="op">(</span>Node <span class="op">*</span>p<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>p<span class="op">)</span> <span class="cf">return</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>size<span class="op">(</span>p<span class="op">-&gt;</span>l<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;=</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        Pair q <span class="op">=</span> split<span class="op">(</span>p<span class="op">-&gt;</span>r<span class="op">,</span> k <span class="op">-</span> size<span class="op">(</span>p<span class="op">-&gt;</span>l<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                   ^ правый сын не знает количество вершин слева от него</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        p<span class="op">-&gt;</span>r <span class="op">=</span> q<span class="op">.</span>first<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        upd<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>p<span class="op">,</span> q<span class="op">.</span>second<span class="op">};</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        Pair q <span class="op">=</span> split<span class="op">(</span>p<span class="op">-&gt;</span>l<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        p<span class="op">-&gt;</span>l <span class="op">=</span> q<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        upd<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>q<span class="op">.</span>first<span class="op">,</span> p<span class="op">};</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Всё. Теперь у нас есть клёвая гибкая структура, которую можно резать как угодно.</p>
<h3 id="пример-ctrlx-ctrlv">Пример: ctrl+x, ctrl+v</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Node<span class="op">*</span> ctrlx <span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    Pair q1 <span class="op">=</span> split<span class="op">(</span>root<span class="op">,</span> r<span class="op">);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    Pair q2 <span class="op">=</span> split<span class="op">(</span>q1<span class="op">.</span>first<span class="op">,</span> l<span class="op">);</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> merge<span class="op">(</span>q2<span class="op">.</span>first<span class="op">,</span> q1<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> q2<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ctrlv <span class="op">(</span>Node <span class="op">*</span>v<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    Pair q <span class="op">=</span> split<span class="op">(</span>root<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> merge<span class="op">(</span>q<span class="op">.</span>first<span class="op">,</span> merge<span class="op">(</span>v<span class="op">,</span> q<span class="op">.</span>second<span class="op">));</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="пример-переворот">Пример: переворот</h3>
<p>Нужно за <span class="math inline">\(O(\log n)\)</span> обрабатывать запросы переворота произвольных подстрок: значение <span class="math inline">\(a_l\)</span> поменять с <span class="math inline">\(a_r\)</span>, <span class="math inline">\(a_{l+1}\)</span> поменять с <span class="math inline">\(a_{r-1}\)</span> и т. д.</p>
<p>Будем хранить в каждой вершине флаг, который будет означать, что её подотрезок перевернут:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> rev<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Поступим по аналогии с ДО — когда мы когда-либо встретим такую вершину, мы поменяем ссылки на её детей, а им самим передадим эту метку:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> push <span class="op">(</span>node <span class="op">*</span>v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">-&gt;</span>rev<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        swap<span class="op">(</span>v<span class="op">-&gt;</span>l<span class="op">,</span> v<span class="op">-&gt;</span>r<span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v<span class="op">-&gt;</span>l<span class="op">)</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>            v<span class="op">-&gt;</span>l<span class="op">-&gt;</span>rev <span class="op">^=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v<span class="op">-&gt;</span>r<span class="op">)</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>            v<span class="op">-&gt;</span>r<span class="op">-&gt;</span>rev <span class="op">^=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    v<span class="op">-&gt;</span>rev <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Аналогично, эту функцию будем вызывать в начале <code>merge</code> и <code>split</code>.</p>
<p>Саму функцию <code>reverse</code> реализуем так: вырезать нужный отрезок, поменять флаг.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reverse <span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    Pair q1 <span class="op">=</span> split<span class="op">(</span>root<span class="op">,</span> r<span class="op">);</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    Pair q2 <span class="op">=</span> split<span class="op">(</span>q1<span class="op">.</span>first<span class="op">,</span> l<span class="op">)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    q2<span class="op">.</span>second<span class="op">-&gt;</span>rev <span class="op">^=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> merge<span class="op">(</span>q2<span class="op">.</span>first<span class="op">,</span> merge<span class="op">(</span>q2<span class="op">.</span>second<span class="op">,</span> q1<span class="op">.</span>second<span class="op">));</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="небольшой-рефакторинг">Небольшой рефакторинг</h3>
<p>Реализация большинства операций всегда примерно одинаковая — вырезаем отрезок с <span class="math inline">\(l\)</span> по <span class="math inline">\(r\)</span>, что-то с ним делаем и склеиваем обратно.</p>
<p>Дублирующийся код — это плохо. Давайте используем всю мощь плюсов и определим функцию, которая принимает другую функцию, которая уже делает полезные вещи на нужном отрезке.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> apply <span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="kw">auto</span> f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    Pair q1 <span class="op">=</span> split<span class="op">(</span>root<span class="op">,</span> r<span class="op">);</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    Pair q2 <span class="op">=</span> split<span class="op">(</span>q1<span class="op">.</span>first<span class="op">,</span> l<span class="op">)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    q2<span class="op">.</span>second <span class="op">=</span> f<span class="op">(</span>q2<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> merge<span class="op">(</span>q2<span class="op">.</span>first<span class="op">,</span> merge<span class="op">(</span>q2<span class="op">.</span>second<span class="op">,</span> q1<span class="op">.</span>second<span class="op">));</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reverse <span class="op">(</span>Node <span class="op">*</span>v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">)</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        v<span class="op">-&gt;</span>rev <span class="op">^=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Применять её нужно так:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>apply<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> reverse<span class="op">);</span></span></code></pre></div>
<p>Это работает в плюсах, начиная с <code>g++14</code>.</p>
<p>Для простых операций можно даже написать лямбду:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>apply<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> <span class="op">[](</span>Node <span class="op">*</span>v<span class="op">){</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>        v<span class="op">-&gt;</span>rev <span class="op">^=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span></code></pre></div>
<h2 id="персистентность">Персистентность</h2>
<p>Так же, как и с ДО, персистентной версией ДД можно решать очень интересные задачи.</p>
<blockquote>
<p>Дана строка. Требуется выполнять в ней копирования, удаления и вставки в произвольные позиции.</p>
</blockquote>
<p>Построим персистентное ДД. Тогда просто вызвав два <code>split</code>-а, мы можем получить копию любой подстроки (указатель вершину), которую потом можно вставлять куда угодно, при этом оригинальную подстроку мы не изменим.</p>
<blockquote>
<p>Дана строка. Требуется выполнять в ней копирования, удаления, вставки в произвольные позиции <strong>и сравнение произвольных подстрок</strong>.</p>
</blockquote>
<p>Можно в вершинах хранить <strong>полиномиальный хэш</strong> соответствующей подстроки. Тогда мы можем проверять равенство подстрок сравниванием хэшей вершин, полученных теми же двумя сплитами.</p>
<p>Чтобы полноценно сравнивать стоки лексикографически, можно применить бинарный поиск: перебрать длину совпадающего суффикса, и, когда она найдется, посмотреть на следующий символ.</p>
<p>Реализация почти такая же, как и для всех персистентных структур на ссылках — перед тем, как идти в какую-то вершину, нужно создать её копию и идти в неё. Создадим для этого вспомогательную функцию <code>copy</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>Node<span class="op">*</span> copy <span class="op">(</span>Node <span class="op">*</span>v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">new</span> Node<span class="op">(*</span>v<span class="op">);</span> <span class="op">}</span></span></code></pre></div>
<p>Во всех методах мы будем начинать с копирования всех упоминаемых в ней вершин. Например, персистентный <code>split</code> начнётся так:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>Pair split <span class="op">(</span>Node <span class="op">*</span>p<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> copy<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>В ДО просто создавать копии вершин было достаточно. Этого обычно достаточно для всех детерминированных структур данных, но в ДД всё сложнее. Оказывается существует тест, который «валит» приоритеты: можно раскопировать много версий одной вершины, а все остальные — удалить. Тогда у всех вершин будет один и тот же приоритет, и дерево превратится в «бамбук», в котором все операции будут работать за линию.</p>
<p>У этой проблемы есть очень элегантное решение — избавиться от приоритетов, и делать теперь следующее переподвешивание: если размер левого дерева равен <span class="math inline">\(L\)</span>, а размер правого <span class="math inline">\(R\)</span>, то будем подвешивать за левое с вероятностью <span class="math inline">\(\frac{L}{L+R}\)</span>, иначе за правое.</p>
<p><strong>Теорема</strong>. Такое переподвешивание эквивалентно приоритетам.</p>
<p><strong>Доказательство</strong>. Покажем, что все вершины всё так же имеют равную вероятность быть корнем. Докажем по индукции:</p>
<ul>
<li>Лист имеет вероятность 1 быть корнем себя (база индукции)</li>
<li>Переход индукции — операция <code>merge</code>. Любая вершина левого дерева была корнем с вероятностью <span class="math inline">\(\frac{1}{L}\)</span> (по предположению индукции), а после слияния она будет корнем всего дерева с вероятностью <span class="math inline">\(\frac{1}{L} \cdot \frac{L}{L+R} = \frac{1}{L+R}\)</span>. С вершинами правого дерева аналогично.</li>
</ul>
<p>Получается, что при таком переподвешивании всё так же каждая вершина любого поддерева равновероятно могла быть его корнем, а на этом основывалось наше доказательство асимптотики ДД.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>Node<span class="op">*</span> merge <span class="op">(</span>Node <span class="op">*</span>l<span class="op">,</span> Node <span class="op">*</span>r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>l<span class="op">)</span> <span class="cf">return</span> r<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>r<span class="op">)</span> <span class="cf">return</span> l<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span> copy<span class="op">(</span>l<span class="op">),</span> r <span class="op">=</span> copy<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>rand<span class="op">()</span> <span class="op">%</span> <span class="op">(</span>size<span class="op">(</span>l<span class="op">)</span> <span class="op">+</span> size<span class="op">(</span>r<span class="op">))</span> <span class="op">&lt;</span> size<span class="op">(</span>l<span class="op">))</span> <span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Философский вопрос: можно ли декартово дерево называть декартовым, если из него удалить и <span class="math inline">\(x\)</span>, и <span class="math inline">\(y\)</span>?</p>
</body>
</html>
